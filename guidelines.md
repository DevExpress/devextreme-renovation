# DevExtreme - Declaration Guidelines

Описание подхода создания нативных компонентов.

## Содержание

- [Цели](#цели)
- [Принципы](#принципы)
- [Декларативные компоненты](#декларативные-компоненты)
  - [Описание компонента](#описание-компонента)
  - [Model](#model)
  - [ViewModel](#viewmodel)
  - [View](#view)
- [Рекомендации](#Рекомендации)
  - [Код](#Код)
  - [Компоненты](#компоненты)
  - [Тестирование](#Тестирование)
  - [Жизненный цикл компонента](#Жизненный-цикл-компонента)
  - [Описание props](#Описание-пропов)
  - [Разметка и стили](#разметка-и-стили)
  - [Использование необъявленных атрибутов](#Использование-необъявленных-атрибутов)
- [Обратная совместимость](#Обратная-совместимость)
  - [Подписка на ивенты](#Подписка-на-ивенты)
  - [Темплейты](#Темплейты)
  - [registerKeyHandler](#registerKeyHandler)
- [Разработка](#разработка)
  - [Исходный код](#Исходный-код)
  - [Тестирование компонентов](#Тестирование-компонентов)
  - [Playground](#Playground)
  - [Use Cases](#use-cases)
  
## Цели

Обеспечение высокого уровня качества. Код должен быть простым, стабильным, быстрым, отвечать современным стандартам разработки и сопровождения.

Обеспечение выпуска нативных компонентов под разные фреймворки на основе единой кодовой базы - мы не должны повторно разрабатывать компоненты для разных фреймворков (существующих и новых).

## Принципы

Для достижения целей было решено разработать систему декларативных компонентов и генераторов.

Разработчик декларативно описывает компонент, набор генераторов преобразует эту декларацию в нативные компоненты для разных фреймворков.

## Декларативные компоненты

В основу описания декларативных компонентов взята *MVVM* модель и *React*-компоненты.

Компонент представляет собой:

- *Model* - описание входных данных;
- *View* (*View*-функция) - представление, *HTML* разметка в *JSX*;
- *ViewModel* - правила преобразования и взаимодействия *Model* и *View* реализованные в виде некоего подобия *React*-компонента.

### Описание компонента

Язык декларативного описания и способ организации кода имеют ряд ограничений, которые могут показаться излишними. Однако, продиктовано это тем, что система построена на пересечении возможностей *target*-фреймворков. Если отойти от этих ограничений, то компоненты в разных фреймворках будут работать по-разному.

Список ограничений неполный, будет пополняться и актуализироваться в процессе написания компонентов.

<details>
  <summary>Пример компонента</summary>
  
  ```tsx
  import {
    Component,
    ComponentBindings,
    Effect,
    Event,
    JSXComponent,
    Method,
    OneWay,
    Ref,
    Slot,
    Template,
    TwoWay
  } from 'devextreme-generator/component_declaration/common';
  import SubComponent from './SubComponent';
  import { subscriber } from './utils/subscriber';
  import pdfjs from 'pdfjs';

  @ComponentBindings()
  export class MyComponentProps {
    @OneWay() readonlyProp?: string = "default value";
    @TwoWay() selected? boolean = false;
    @Event() onSmthHappened?: () => void;
    @Template() userTemplate?: any;
    @Slot() namedSlot?: any;
  }

  @Component({
    view: viewFunction
  })
  export default class MyComponent extends JSXComponent<MyComponentProps> {
    innerState: boolean = false;

    @Ref() rootRef! HTMLDivElement;

    @Effect()
    atomicEffect() {
      const id = subscriber.on(() => {
        this.innerState = !this.innerState;

        this.props.onSmthHappened();
      });
      return () => subscriber.off(id)
    }

    @Method()
    export() {
      return pdfjs.fromHtml(this.rootRef);
    }

    onClick() {
      this.props.selected = !this.props.selected;
    }

    get childProp(): string {
      return this.innerState && this.props.selected ? "a" : "b";
    }
  }

  function viewFunction(viewModel: MyComponent) {
    const hasTemplate = !!viewModel.props.userTemplate;
    return (
      <div
        ref={viewModel.rootRef as any}
        className="my-class"
        { ...viewModel.restAttributes }
      >
        {hasTemplate &&
          <viewModel.props.template
            someProp={viewModel.childProp}
            parentRef={viewModel.rootRef}
          />
        }
        {!hasTemplate &&
          <SubComponent someProp={viewModel.childProp} onClick={viewModel.onClick} />
        }
        { viewModel.props.readonlyProp }
        { viewModel.props.namedSlot }
      </div>
    );
  }
  ```

</details>

#### Model

Для описания модели используется помеченный декоратором `@ComponentBindings()` класс. Все поля этого класса так же помечаются необходимыми декораторами.

Поля модели, по возможности, должны быть необязательными.

Использование конструктора не допускается. Класс служит только для описания структуры модели и не должен иметь поведения.

##### Декораторы членов класса

- `@OneWay()` - обеспечивает одностороннюю связь данных. Служит для передачи данных, на основе которых компонент решает, что и как ему отобразить во *View*. *OneWay* пропы нельзя изменять, их можно только читать (см `readonlyProp` в примере);

- `@TwoWay()` - обеспечивает двустороннюю связь данных. Может быть изменен компонентом, при этом пользователь компонента получит оповещение об этом изменении через дополнительно сгенерированный *change*-ивент. Технически, в компоненте автоматически сгенерируется дополнительный *event* `${propName}Change`. Однако, есть случаи, когда его все же необходимо объявить (будет рассмотрено в секции [юзкейзов](#use-cases)). Его обновление также приводит к циклу перерисовки компонента. См. в примере проп `selected`;

- `@Event()` - это колбек, который вызывается компонентом, при возникновении определенного события. Колбек должен принимать не более 1 параметра;

- `@Template()` - проп, содержащий компонент или *render*-функцию для кастомной отрисовки контента. В декларативном компоненте темплейтами могут быть другие декларативные компоненты;

- `@Slot()` - проп, через который можно передать некий контент для прямого отображения. В *Angular* это называется *transcluded content*, в *React* это просто *JSX* разметка. Если в компоненте объявлен слот с именем `default`, в него придет дочерний контент компонента из разметки пользователя компонента. Это аналог `children` в *React*.

#### ViewModel

Для описания *ViewModel* используется класс, помеченный декоратором `@Component()` и наследующий `JSXComponent` от класса *Model*. В декораторе компонента обязательно указывается *View*-функция, а так же опционально дополнительные параметры.

```typescript
@Component({
  view: viewFunction,
  defaultOptionRules,
  registerJQuery: true
})
```

- `view` - чистая функция, возвращающая *HTML* разметку. Её аргументом является объект, содержащий члены класса `ViewModel` и объект **props**, содержащий члены класса *Model*;

- `defaultOptionRules` - правила задания дефолтных пропертей относительно девайса (см *button.tsx*);

- `registerJQuery` - определяет будет ли компонент зарегистрирован как *jQuery* виджет. Это нужно делать только для компонентов, которые будут создаваться через `$().dxWidgetName()`.

##### Декораторы членов класса

- `@Ref()` - декоратором помечаются члены, которые являются ссылками на ноды либо другие компоненты. Эти члены обязательно передавать как проп `ref` компонентов или нод в разметке (`<div ref={myRef} />`). См. `rootRef` в примере, а также [описание рефов в React](https://ru.reactjs.org/docs/refs-and-the-dom.html);

- `@Effect()` - метод, в котором можно запустить код для работы с *DOM* и только в нём! См. пример, в нем организована синтетическая подписка на *DOM* элемент. Аналог [useEffect в реакте](https://ru.reactjs.org/docs/hooks-reference.html#useeffect);

- `@Method()` - этим декоратором помечаются методы, которые представляют внешнее *API* компонента. Для примеров - экспорт, принт, фокус. Методы должны использоваться только в редких случаях, когда нельзя что-то решить через входные пропы, либо если надо что-то юзеру отдать, что не может быть отдано через `@TwoWay` пропы и ивенты.

Так же класс компонента может содержать члены без декораторов:

- `Методы` - вспомогательные методы преобразования модели, хэндлеры событий и прочее;

- `Свойства` - хранят внутреннее состояние компонента. Запись в эти свойства приводит к циклу перерисовки компонента. Пользователь не получает никаких оповещений об изменении внутреннего состояния, так же нет возможности задать его значение извне;

- `Геттеры` - предоставляют удобный способ задания пропертей *ViewModel*. Хотя можно для этого использовать и обычные методы, делать в *JSX* разметке вызовы этих методов, предпочтительно использовать геттеры. Это упростит код (особенно итогового *Angular* компонента). Геттеры не должны менять состояние, или еще как-то модифицировать что-то. Их назначение - преобразовать пропы и состояние в пригодный для *View* вид. Думайте о них, как об аналогах чистых функций (хоть они и не принимают ничего на входе). Никаких сайдэффектов.

Использование конструктора не допускается. Наследование от других компонентов (кроме `JSXComponent`) не допускается.

Все методы и геттеры компонента должны содержать только высокоуровневую логику, напрямую оперирующую данными компонента. Любой другой код должен быть вынесен в отдельные утилиты. Особенно это относится браузеро/платформенно зависимому коду (работа с *DOM*, ивентами и проч). Это нужно для легкого чтения/тестирования логики компонентов.

**Важно!** Базовый `JSXComponent` содержит поле `restAttributes`, которое предоставляет возможность передать в рутовый элемент кастомные, неописанные в модели, параметры. См [Использование необъявленных атрибутов](#Использование-необъявленны-атрибутов)

#### View

Для объявления *View* используется функция, принимающая экземпляр класса компонента и возвращающая *JSX* разметку. В качестве *ViewModel* используется экземпляр класса компонента, помеченного декоратором `@Component()`. Используйте его геттеры, состояние и пропы.

Код во *View* должен быть максимально простым. Сложные конструкции могут привести к неверной генерации компонентов. Один из примеров - *switch*. Вместо него предпочтительнее использовать логические операторы.

*View*-функция — это так же единственное место в компоненте, где можно создавать *JSX* разметку. Ни в методах, ни в геттерах *ViewModel*, ни во вспомогательных функциях разметки быть не должно. Если вам кажется, что можно куда-то выделить часть разметки — значит вам надо создать новый компонент. Нет ничего плохого в визуальном компоненте, который отвечает только за рендер, не имеющем состояния и поведения.

Так же возвращаемая разметка из *View* должна содержать 1 рутовый элемент. Если вам необходимо вернуть несколько, оберните их в специальный элемент `Fragment` (см. [Use cases](#JSX))

## Рекомендации

### Код

Реновированный *DevExtreme* написан на *typescript*. Это значит, что надо четко указывать типы, никаких `any`.  

Не сохраняйте `this` в `that`, вообще под `this` должен скрываться только компонент, не переключайте контекст, используйте стрелочные функции.

Мы не используем *jQuery*, в компонентах нет места для `$`. Это касается и нашей подмены *jQuery*, утилит и прочего.

Ранее уже написано - код компонента должен содержать только логику, необходимую для работы этого компонента. Если появляется сторонняя логика - это либо признак того что компонент необходимо разбить на несколько компонентов, либо что вы пишете утилитную логику, которая должна быть выделена в отдельную утилиту и протестирована отдельно от логики компонента.

Особенно это касается работой с *DOM* и прочими браузерными штучками.

Опять же, все утилиты (и прочий общий код) должны быть реюзабельными, не стоит плодить один и тот же функционал, завернутый в разный код.

### Компоненты

**Одно из самых главных - создать набор простых, реюзабельных компонентов.** Если вам нужен какой-то простой компонент, посмотрите, нет ли уже существующего. Возможно, такой уже есть, и вы можете его использовать. Возможно он немного специфичен и его необходимо чуть-чуть видоизменить. Если его нет, то создавайте его таким, чтоб другие могли его использовать.  

Тут так же важно не делать швейцарские ножи, мощные и универсальные компоненты, с кучей пропов, которые можно использовать в многих местах, но которые будут выглядеть по-разному (ну пропов же много). **Компоненты должны быть простыми, решать одну задачу.**

Например, кнопка. У кнопки одно простое предназначение, вид ее ожидаемый. Не стоит в разных больших компонентах заводить свои кнопки, просто потому что вам кажется, что она тут немного другая, имеет еще какую-то функцию. Все эти нестыковки и желания могут быть решены другими способами, например созданием компонентов высшего порядка (*HOC*). Вариантов много, вы все о них читали в интернетах.

Q. Так что же, могу наследоваться от кнопки и сделать свою, с блэк джеком и куртизанками, как я всегда делал в *DevExtreme*?

А. Нет. В новом *DevExtreme* мы отказались от наследования. Если у какого-то компонента нет нужной вам фичи и этому компоненту она не нужна - создайте новый *HOC* компонент, в нем отрисуйте имеющийся, пробросьте ему пропы, обработайте новые и дело готово.  

Но наследование как фича языка конечно не запрещена. В примере выше она как раз имеет место быть и очень полезна. Для чего? Классы модели, в случае такого вот построения *HOC* компонента, удобно наследовать от оборачиваемого компонента. Сделано это для того, чтобы не переобъявлять заново всю модель.

Пример наследования модели и включения компонентов (а не прямое наследование) уже есть. Все главные компоненты (те, которые были и будут зарегистрированы как *jQuery* виджеты) устроены таким образом, что наследуют модель от главного виджета, а свой контент рисуют как *children* этого виджета.

См *button.tsx* в нашей базе. *Button* не наследует *Widget*, однако весь функционал виджета теперь есть в кнопке.

### Тестирование

Одно из важных условий это 100% code coverage. Вся логика компонента, *View*, должны быть протестированы.

Тестировать надо не конечные нагенеренные компоненты во всех фреймворках, а декларативные компоненты, только их логику и код.

Вот почему весь лишний код надо выносить из компонентов и тестировать отдельно. Этот код может потребовать наличия браузеров в тестовой системе, еще какие-то вещи.

Быстрые, легкие и понятные unit-тесты - основа тестирования, гарантия стабильной работы всех компонентов.

Система тестирования, облегчающая написание и построение тестов, еще находится в разработке.

Этот пункт еще будет дополняться.

### Описание пропов

Очень важно, чтобы модель была описана целиком и полностью, не допускается каких-то неявных расширений, неописанных параметров. В *React* можно неописанные пропы передавать в компонент, а в *Angular* нельзя - отсюда такое ограничение.

Так же старайтесь не делать обязательных параметров в *Model*. Это может привести к нежелательному и неочевидному поведению, а так же к разному поведению в разных фреймворках. Вы можете указать дефолтное значение любого параметра, поэтому нет необходимости в обязательных параметрах.

### Жизненный цикл компонента

Хотя технически компонент записан в виде класса, лучше всего думать о нем, как о функции. Эта функция принимает на вход параметры и выдает разметку. Да, это функциональный react-компонент. Наш компонент в *React* представляет из себя именно функциональный компонент.

Поэтому *Model* это и есть входные данные, а *View* это вывод функции. Никаких других источников данных, знаний и прочего не должно быть.

Отсюда следует, что любое изменение пропертей, которое мы хотим внести приведет к перерисовке, и компонент целиком и полностью полагается на модель.

Любое изменение `@TwoWay` пропа нигде не сохраняется, оно заставит перерисоваться компонент, а новое значение будет в модели (и не факт, что именно то, которое вы туда записали).

Только запись в свойства самого комопнента сохраняются в нем, но вызывают такой же новый цикл рендера.

### Разметка и стили

При реновировании какого-либо компонента старайтесь сохранять *HTML* структуру, это позволит по максимуму утилизировать имеющиеся стили. Но здесь кроется подводный камень - при выделении мелких компонентов, в итоговой разметке *Angular* компонентов появятся промежуточные кастомные теги (вы их все помните, *dx-button*, *dx-list-item* и прочие), тогда как в *React*, *Vue*, *jQuery* их не будет, будут обычные дивы.

Поэтому стоит особое внимание обращать на существующие стили, чтобы в них не было правил, полагающихся на структуру тегов разметки. Используйте классы.

Отсюда же естественный вывод - в реюзабельных компонентах имена классов не должны отсылать к чему-то большему, они должны относиться только к этому компоненту. Внешний компонент при необходимости сможет перекрыть/изменить стили внутреннего компонента.

### Использование необъявленных атрибутов

Одним из преимуществ нативных компонентов является добавление любых пользовательских атрибутов в *HTML* разметку. В *Angular* и *Vue* это решается на стороне самих фреймворков, для поддержки в *React* необходимо использовать геттер `restAttributes` - его не надо объявлять, он доступен сразу в первом аргументе *View* функции.

Этот геттер возвращает объект **дополнительных** атрибутов, которые пользователь повесил на нативный компонент.

Всегда предавайте `restAttributes` в рутовый эелемент (компонент это или нет) вьюхи. См. пример.

Есть два варианта использования

1. Пробросить в одноименный проп компонента *Widget*. Внутри *Widget* сделает все сам 🤗;
2. Добавить все проперти объекта в *HTML* разметку с помощью *spread* оператора.

   ```tsx
   <div
    {...restAttributes}
   >
   </div>
   ```

## Обратная совместимость

Мы не можем отказаться от многого, что есть в текущем *DevExtreme*, поэтому что-то в декларации будет выглядеть лишним, какие-то фичи фреймворков нельзя использовать.  

Сколько это продлится - вопрос открытый, но пока мы с этим живем.

### Подписка на ивенты

Мы не можем использовать нативные ивенты фреймворков. Мы могли бы подписаться на `click` ивент прям в *JSX* разметке и иметь нативные ивенты в каждом фреймворке. Но мы должны поддержать наши старые *dxEvents*. Поэтому все подписки на ивенты совершайте из `@Effect()`. См. примеры в *button.tsx* и *widget.tsx*

### Темплейты

Для поддержки старого поведения в *jQuery* виджетах необходимо в темплейты передавать *ref* на ноду, в которой будет рисоваться темплейт. *ref* надо объявить, указать в разметке и передать в темплейт (как проп `parentRef`). Выглядит это лишним, когда смотришь на компонент.

```jsx
<div ...>
  …
  <div ref={viewModel.templateRef} >
    {viewModel.template &&  
      <viewModel.template
        parentRef={viewModel.templateRef}
        someProp={viewModel.someProp} />
    }
    {!viewModel.template &&
      <div>Default content</div>
    }
  </div>
</div>
```

Также из примера выше видно, что дефолтных темплейтов теперь нет. Проп темплейт теперь содержит только переданный извне темплейт. Никакого хранилища дефолтных темплейтов нет. Любой дефолтный вид компонента теперь не в темплейте, а прямо во *View*-функции. Но можно, конечно, завести небольшой компонент и рисовать его, если нет темплейта.

### registerKeyHandler

Для поддержки корректной работы этого метода в *jQuery* виджетах, в декларативных виджетах надо добавить *onKeyDown* ивент и правильно его обработать.

Корневой компонент (*Widget.tsx*) уже имеет такой ивент, райзит его на нажатии любой клавиши клавиатуры. В вашем компоненте надо на него подписаться, и делать свои действия (если вашему компоненту надо что-то делать при нажатии на клавиши). Однако сначала вам надо вызвать свой проп-ивент `onKeyDown`, и если он вернет `cancel == true`, то не выполнять свое действие.

См `onWidgetKeyDown` в *Button.tsx*

```typescript
onWidgetKeyDown(event: Event, options) {
  const { onKeyDown } = this.props;
  const { keyName, which } = options;

  const result = onKeyDown?.(event, options);
  if (result?.cancel) {
    return result;
  }

  if (...) {
    event.preventDefault();
    this.onWidgetClick(event);
  }
}
```

## Разработка

Пока что разработка новых компонентов ведется в ветке [preact-button](https://github.com/DevExpress/DevExtreme/tree/preact-button). Все компоненты пока размещаются в папке [js/renovation](https://github.com/DevExpress/DevExtreme/tree/preact-button/js/renovation).

### Исходный код

Все декораторы, а так же базовый `JSXComponent` необходимо импортировать из `devextreme-generator/component_declaration/common`.

Стартовый шаблон кода компонента:

```tsx
import {
  Component,
  ComponentBindings,
  JSXComponent,
  OneWay,
} from 'devextreme-generator/component_declaration/common';

export const viewFunction = (viewModel: Component) => {
  return (<div></div>);
};

@ComponentBindings()
export class ComponentProps {
  // Your props go here
}

@Component({
  view: viewFunction,
})
export default class Component extends JSXComponent<ComponentProps> {
  // ViewModel getters, Effects, Refs, go here  
}
```

Так же смотрите пример выше в этом гайде и уже реализованные компоненты в `js/renovation`.

### Тестирование компонентов

Тесты на декларации написаны с использование *jest*. Примеры тестов на существующие компоненты см в [testing/jest](https://github.com/DevExpress/DevExtreme/tree/preact-button/testing/jest).

Для подготовки (компиляции) компонентов к тестированию, необходимо воспользоваться тасками `test-env`, `dev`, либо *gulp* таской `generate-components`. Рядом с вашим декларативным компонентом появится файл с расширением *.p.js*. (Это *Preact* компонент, сгенерированной из декларации. Пока что он используется для тестирования)

Так же ознакомьтесь с информацией в [разделе тестирования](#тестирование)

!! Раздел дополняется

### Playground

В папке *playground* есть приложения на *Angular* и *React*, демонстрирующие новую кнопку.

Для того, чтобы можно было посмотреть вживую на работу компонента в плейграунде его нужно скомпилировать под нужный фреймворк. Воспользуйтесь билдежными тасками

*React* - `build:react` либо `build:react:watch`

*Angular* - `build:angular` либо `build:angular:watch`

*jQuery* - если в декораторе вашего компонента указано `registerJQuery: true`, то при запуске тасок `build`, `dev`, `test-env` в дополнение к *Preact*-компоненту сгенерируется и *jQuery* враппер над ним. Имя для *jQuery*-виджета совпадает с именем компонента (без приставки `dx`).

### Use Cases

В этом разделе опишем подробнее как и для чего использовать те или иные декораторы, конструкции и прочее. А так же более интересные примеры и случаи.

#### @OneWay()

Этим декоратором помечаются обычные пропы компонента. Если ваш компонент ожидает чего-то на входе, что он будет **только читать**, то это оно.

Например, `type`, `title` и т.д. элемента `<input>`

```tsx
@ComponentBindings()
class MyComponentProps {
  @OneWay() type?: 'bad' | 'good' = 'good';
}

@Component({ view: viewFunction })
class MyComponent extends JSXComponent<MyComponentProps> {
}

function viewFunction(viewModel) {
  return <span>I'm a {viewModel.props.type} guy</span>
}
```

`OneWay` пропы можно только читать, они предоставляют компоненту некую информацию, необходимую ему для правильного отображения, определения поведения и прочее.

#### @TwoWay()

`TwoWay` пропы делают все то же самое, что и `OneWay`, предоставляют компоненту входные параметры.

Однако, `TwoWay` значение может быть изменено как пользователем, так и самим компонентом изнутри. Поэтому он и называется двухсторонним.

При присваивании нового значения произойдет перерендер компонента, при этом новое значение можно будет считать из этого пропа.

Так же пользователь вашего компонента получит оповещение, что значение этого пропа сменилось. В *React* можно будет подписаться на специально созданный ивент, в *Angular* можно будет настроить двусторонний байндинг и т.п.

Технически это значит следующее:

На всякий `TwoWay` проп заводится еще `Event` с `propName`+`Change`, а так же `OneWay` проп `default`+`PropName`.

Но вам не надо ни вызывать этот *сhange*-ивент, ни считывать значение из *default* пропа. Их даже не нужно объявлять в большинстве случаев.

А в каких случаях надо их объявить? Если вы создаете компонент (A), который хочет подписаться на *сhange*-ивент другого компонента (B), то у компонента (B) должен быть объявлен необходимый `Event`. Это нужно только для корректной передачи пропов в декларации, на сгенерированный код это никак не влияет.

Аналогичная ситуация с `default` пропом. Если необходимо передать не сам проп, а его `default` собрата, то важно, чтобы он был задекларирован в компоненте. Это нужно только для декларации.

**Еще раз. Наличие или отсутствие этих пропов в декларации не влияет на конечный результат генерации.**

Q. Почему это так сложно сделано? Почему мне нельзя самому завести стейт, его менять, вызывать *change*-ивент и смотреть на дефолтное значение?

A. Потому что в разных фреймворках мы генерируем немного разные конструкции (хоть в их сути и лежит одно и то же). А так же эти конструкции позволяют использовать наши компоненты в *controlled* и *uncontrolled* режимах.

Рассмотрим эти режимы подробнее

У нас есть компонент, который имеет `TwoWay` проп и меняет его по клику. Некий счетчик.

```tsx
@ComponentBindings()
class MyComponentProps {
  @TwoWay() value?: number = 0;
}

@Component({ view: viewFunction })
class MyComponent extends JSXComponent<MyComponentProps> {
  onClick() {
    this.value = this.value + 1;
  }
}

function viewFunction(viewModel) {
  return <span>Counter - {viewModel.props.value}</span>
}
```

Мы тут не задавали ни ивента, ни дефолтного пропа. Но они есть :)

**Сценарий 1**

Пользователь просто создал компонент и ему больше ничего не интересно. От каких-то манипуляций с *UI* конечного пользователя меняется значение `TwoWay` пропа, и компонент будет перерисовывается.

```tsx
<MyComponent />
```

**Сценарий 2**

Пользователь компонента хочет знать об изменениях этого значения, но на этом все. Он получит оповещение, новое значение и что-то там у себя сделает.

```tsx
<MyComponent valueChange={onCounterChange} />

onCounterChange(counter) {
  log(counter)
}
```

Тут каждый раз при клике на нашем компоненте, вышестоящий компонент будет логировать числа 0,1,2,3...

**Сценарий 3**

Этот сценарий опять же принципиально не отличается от первых двух. Но тут пользователю компонента нужно еще задать начальное (дефолтное) значение. Но на этом все, он больше ничего с ним делать не собирается, ему важно только знать о его изменении.

```tsx
<MyComponent defaultValue={5} valueChange={onCounterChange} />

onCounterChange(counter) {
  log(counter)
}
```

Тут каждый раз при клике на нашем компоненте, вышестоящий компонент будет логировать числа, начиная с 5 - 5,6,7,8...

Для нас эти три сценария ничем не отличаются - мы на новом цикле рендера получим то значение, которое записали в `TwoWay` проп.

Это значит, что наш компонент никто не контролирует, мы сами установили новое значение и его же и получаем.

**Сценарий 4**

Пользователь компонента указывает (или нет) дефолтное значение, подписывается на изменение, а также он принимает решение, что же делать с этим измененным значением перед отправкой обратно в компонент, ну например он хочет сбрасывать счетчик после 5.

Он контролирует наш компонент, он решает какое мы значение получим. Хоть мы и записали в проп новое значение, на рендере нам может придти другое значение и мы его и будем рисовать

```tsx
<MyComponent value={counterValue} defaultValue={1} valueChange={onCounterChange} />

onCounterChange(counter) {
  this.counterValue = 5 // здесь в реакте скорее всего будет некий setState, а в Ангуляре нет,нам это сейчас не важно
  
  if(counter > 5)
    this.counterValue = 1

  log(this.counterValue)
}
```

В этом случае будут залогированы последовательности с 1 по 5.

**Выводы**

Нам в компоненте не нужно ничего делать, чтобы поддержать эти два режима, мы просто объявляем `TwoWay` проп и присваиваем ему значение, когда надо. А потом просто на рендере считываем из пропа значение и его рисуем. Мы не зовем *change*-ивент, мы не обращаем внимание на *default* проп. Это все не нужно для написания декларативного компонента, мы пишем только логику - а логика у нас это смена значения.

Однако если представить, что вот примеры выше это все тоже наши декларативные компоненты, то чтобы *typescript* не ругался и мы в декларативных компонентах видели, что там есть все такие *change*-ивент и дефолтный проп, их нужно задекларировать.

Поэтому наш компонент будет выглядеть так:

```tsx
@ComponentBindings()
class MyComponentProps {
  @TwoWay() value?: number = 0;
  @OneWay() defaultValue?: number = 0;
  @Event() valueChange?: (value: number) => void;
}

@Component({ view: viewFunction })
class MyComponent extends JSXComponent<MyComponentProps> {
  onClick() {
    this.value = this.value + 1;
  }
}

function viewFunction(viewModel) {
  return <span>Counter - {viewModel.props.value}</span>
}
```

Я объявил, но не использую в декларативном компоненте ни ивент, ни дефолтный проп.

**Важно** Исходя из вышесказанного, надо быть аккуратнее в тестах. Обращать внимание в каком режиме вы используете ваш комопнент в тестах.

Если вы хотите протестировать логику смены значения `TwoWay` пропа и проверяете его через отрисовку - не назначайте сам проп компоненту.

Еще раз вспомним [жизненный цикл нашего компонента](#Жизненный-цикл-компонента).

#### @Event()

Как вы уже догадались, этот проп это колбек. Зачем его отделять от `OneWay` пропа, можно же в простой проп функцию передать?

Да, можно, но для других каких-то целей (например для темплейтов). А если вы хотите правильные ивенты во всех фреймворках, помечайте такие пропы `Event` декоратором - это обеспечит корректную работу (файринг) ивентов везде.

Так вот, ивент - это колбек, принимающий 1 параметр и возращающий или ничего или результат с *cancel* и прочее. Главное тут это 1 параметр.

Из нашего же примера выше видно как задать ивент. Однако мы его там не звали. Так давайте это исправим. В примере мы позовем колбек на клике, проверим результат и отменим дефолтное действие.

```tsx
@ComponentBindings()
class MyComponentProps {
  @OneWay() type?: 'bad' | 'good' = 'good';
  @Event() onClick?: (e: { type: 'bad' | 'good' }) => any;
}

@Component({ view: viewFunction })
class MyComponent extends JSXComponent<MyComponentProps> {
  onClickHandler() {
    const { cancel } = this.props.onClick?({ type: this.props.type })
    if(cancel) {
      return;
    }

    // Do something
  }
}

function viewFunction(viewModel) {
  return <span>I'm a {viewModel.props.type} guy</span>
}
```

#### @Ref()

Рефы предоставляют ссылку на элемент или другой компонент для доступа к *DOM* или *API* другого компонента.

Для корректной инициализации рефов их надо объявить и передать как спец-проп `ref` в нужный элемент (компонент):

```tsx
@ComponentBindings()
class MyComponentProps {}

@Component({ view: viewFunction })
class MyComponent extends JSXComponent<MyComponentProps> {
  @Ref() rootRef!: HTMLDivElement;
}

function viewFunction(viewModel: MyComponent) {
  return (
    <div ref={viewModel.rootRef}></div>
  );
}
```

Примеры использования рефов смотри ниже.

#### @Method()

Этим декоратором помечаются методы компонента, которые должны представлять внешнее *API*.

Особое внимание стоит уделить тому, что *API* должно содержать только минимум необходимых методов - все, что может быть сделано через пропы, должно быть сделано через них.

Классическим примером такого *API* является *focus* и *export/print*.

Переключить видимость, открыть/закрыть дровер и прочие **НЕ** являются примером *API* - эти примеры могут и должны быть решены через пропы.

Итак, в теле методов, помеченных как `Method` есть доступ к *DOM*. Однако как указывалось ранее, лучше код работы с *DOM* и т.п. выделить в отдельную утилиту, протестировать отдельно, а в компоненте уже решать вопросы на более высоком уровне.

**Важно!** Также не допускается вызывать `Method` методы на стадии рендера (из *View*- функции, геттеров вьюмодели и тп), их может вызвать только другой компонент, либо код, тригерящийся от действий конечного пользователя (на обработчиках событий, например) - в общем когда компонент уже отрендерен.

```tsx
@ComponentBindings()
class MyComponentProps {
  @OneWay() type?: 'bad' | 'good' = 'good';
}

@Component({ view: viewFunction })
class MyComponent extends JSXComponent<MyComponentProps> {
  @Ref() rootRef!: HTMLDivElement;

  @Method()
  export(format: string) {
    if(false) {
      // Реф используется как элемент, на который он указывает
      return this.rootRef.innerHTML;
    }
    // Но лучше как-то так
    return exportUtils.exportElement(this.rootRef, format);
  }
}

function viewFunction(viewModel: MyComponent) {
  return (
    <div ref={viewModel.rootRef}>
      <span>I'm a {viewModel.props.type} guy</span>
    </div>
  );
}
```

Доступ к *API* одного декларативного компонента внутри другого осуществляется через *ref*.

```tsx
import MyEditorComponent from './my_funny_editor';

@ComponentBindings()
class MyComponentProps {
  @OneWay() type?: 'bad' | 'good' = 'good';
}

@Component({ view: viewFunction })
class MyComponent extends JSXComponent<MyComponentProps> {
  @Ref() editorRef?: MyEditorComponent;

  @Method()
  focus() {
    // У компонента MyEditorComponent есть API метод, помеченный декоратором @Method()
    return editorRef?.focus();
  }
}

function viewFunction(viewModel: MyComponent) {
  return (
    <div>
      <MyEditorComponent ref={viewModel.editorRef} editorProp={viewModel.props.type} />
    </div>
  );
}
```

#### @Template()

В этом пропе в компонент придет нечто, что можно можно отрисовать, передав ему какие-то параметры-пропы. Можно представить, что это другой компонент или *render*-функция.

Все что нам нужно - корректно указать *props* во *View*-функции. Ну собственно так, будто мы просто рендерим другой компонент.

Ну и наши декларативные компоненты конечно могут выступать в роли темплейтов в других компонентах.

Так же с целью обеспечения [обратной совместимости](#Темплейты) для *jQuery* виджетов в темплейт необходимо передавать *ref* на родительский контейнер. При этом парент для темплейта и дефолтного контента (если он предполагается) должен быть одним и тем же.

```tsx
@ComponentBindings()
class MyComponentProps {
  @OneWay() item?: Item;
  @Template() itemTemplate?: any;
}

@Component({ view: viewFunction })
class MyComponent extends JSXComponent<MyComponentProps> {
  @Ref() templateParentRef!: HTMLDivElement;
}

function viewFunction(viewModel) {
  const useTemplate = !!viewModel.props.itemTemplate;
  return (
    <div ref={viewModel.templateParentRef}>
      {
        useTemplate &&
        <viewModel.props.itemTemplate
          item={viewModel.props.item}
          parentRef={viewModel.templateParentRef} />
      }

      {
        !useTemplate &&
        <span>{viewModel.props.item.text}</span>
      }
    </div>
  );
}
```

#### @Slot()

Этим декоратором необходимо помечать пропы, которые предполагается использовать для рендера готового контента от пользователя. Технология имеет много имен, но принцип один и тот же - необходимо в компоненте отобразить уже готовую разметку.

В *Angular* это *Content Projection*, в *Vue* это слоты и т.п.

Слоты могут быть именованными и неименованными. Однако, в наших компонентах все слоты именованные. С одним небольшим нюансом - если вы определите слот с именем `default`, то он будет использоваться в соответствующих технологиях на местах неименованного слота - в этот слот попадает весь контент, который не попадает в другие именованные слоты (ну а в Реакте это проп `children`).

Рассмотрим пример задания слотов в компоненте и использование их снаружи

```tsx
@ComponentBindings()
class ComponentWithSlotsProps {
  @Slot() default?: any;
  @Slot() namedSlot?: any;
}

@Component({ view: viewFunction })
class ComponentWithSlots extends JSXComponent<ComponentWithSlotsProps> {
}

function viewFunction(viewModel: ComponentWithSlots) {
  return (
    <div>
      <div>
        { viewModel.props.namedSlot }
      </div>
      <div>
        { viewModel.props.default }
      </div>
    </div>
  );
}
```

```tsx
import ComponentWithSlots from './component-with-slots';

@ComponentBindings()
class MyComponentProps {
}

@Component({ view: viewFunction })
class MyComponent extends JSXComponent<MyComponentProps> {
}

function viewFunction(viewModel: MyComponent) {
  return (
    <ComponentWithSlots
      namedSlot={
        <div>
          Content for named slot
        </div>
      }
    >
      <div>
        Default content
      </div>
    </div>
  );
}
```

В *DevExtreme* есть поддержка анонимных темплейтов, в новом *DevExtreme* стоит использовать слоты.

#### @Effect()

Этим декоратором помечаются методы компонента, которые вызываются после того, как компонент отобразится в дереве. Внутри этих методов можно обращаться к реальному DOM с помощью [рефов](#@Ref()).

Зачем использовать Эффекты - для взятия реальных размеров, для оформления всевозможных подписок и так далее. В общем всего того, что нельзя сделать декларативно. Обычно здесь находится код, который каким-либо образом взаимодействует с разметкой.

Компонент может содержать сколько угодно эффектов. Вообще один эффект (метод) должен быть посвящен чему-то одному. Старайтесь логически разбивать клиентскую функциональность на эффекты. Разные по природе эффекты должны оформляться в разных методах.

Если вы делаете некие подписки в эффекте, то вам необходимо вернуть колбек отписки.

Стоит помнить, что все эффекты вызываются асинхронно, так же в разных фреймворках их реализация отличается. Поэтому и воспринимать их надо как атомарные действия, которые не зависят друг от друга и выполняются асинхронно (не сразу в момент рендера), а после. Не стоит закладываться на порядок их выполнения.

Для большей информации смотрите хук [useEffect](https://reactjs.org/docs/hooks-effect.html) в *React*.

```tsx
import { subscriber } from './utils/subscriber';

@ComponentBindings()
class MyComponentProps {
    @OneWay() p: string = "10";
    @TwoWay() s: number = 10;
}

@Component({
    view: viewFunction
})
class MyComponent extends JSXComponent<MyComponentProps> {
    @Effect()
    singleEffect() {
      const id = subscriber.on(() => {
        // do something
      });
      return () => subscriber.off(id)
    }
}

function viewFunction(viewModel: MyComponent) {
  return (<div></div>);
}
```

#### JSX

Как уже писалось ранее, мы используем *JSX* для описания разметки компонента. Любой код на *JSX* должен быть только внутри *View*-функции.

Так же *View*-функция должна вернуть *JSX* разметку с одним корневым элементом. Если ваш компонент должен вернуть более одного, их следует обернуть в специальный элемент `Fragment`, который не будет отображен в дереве.

```tsx
import { Fragment } from 'devextreme-generator/component_declaration/common';

@ComponentBindings()
class MyComponentProps {
}

@Component({ view: viewFunction })
class MyComponent extends JSXComponent<MyComponentProps> {
}

function viewFunction(viewModel: MyComponent) {
  return (
    <Fragment>
      <div>
        First element
      </div>
      <div>
        Second element
      </div>
    </Fragment>
  );
}
```
