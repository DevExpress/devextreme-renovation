# Цели
Оздоровление кодовой базы - код должен быть простым, стабильным, быстрым, отвечать современным стандартам разработки и сопровождения

Обеспечение выпуска нативных компонентов под разные фреймворки на основе единой кодовой базы - мы не должны повторно разрабатывать компоненты для разных фреймворков (существующих и новых)

# Принципы 
Для достижения целей было решено воспользоваться системой декларативных компонентов и генераторов. Разработчик декларативно описывает компоненты, генераторы преобразуют эти декларации в нативные компоненты для разных фреймворков.

Система декларативного описания также призвана помочь в достижении первой цели, однако в большей степени этому должна поспособствовать дисциплина разработки и межсквадового общения.

# Декларативные компоненты 
В основу новых компонентов взята MVVM модель и React-компоненты.

Компонент представляет из себя Model (Входные данные), представление (View) и правила преобразования и взаимодействия (ViewModel) реализованный в виде некоего подобия React-компонента. Примеры реализации различных юзкейзов будут даны ниже.

## Описание декларативного компонента 
<details>
  <summary>Пример компонента</summary>
  
  [Пример компонента](https://gist.github.com/pavelgruba/0b1e9b3a3ecbc99bd33056706a6e5f3f#file-mycomponent-tsx-L50)  
  
  ```typescript
  import { 
    Component,
    ComponentBindings,
    Effect,
    Event, 
    JSXComponent, 
    Method,
    OneWay, 
    Ref,
    Slot,
    Template, 
    TwoWay 
  } from 'devextreme-generator/component_declaration/common';
  import SubComponent from './SubComponent';
  import { subscriber } from './utils/subscriber';
  import pdfjs from 'pdfjs';

  @ComponentBindings()
  export class MyComponentProps {
    @OneWay() readonlyProp?: string = "default value";
    @TwoWay() selected? boolean = false;
    @Event() onSmthHappened?: () => void;
    @Template() userTemplate?: any;
    @Slot() namedSlot?: any;
  }

  @Component({
    view: viewFunction
  })
  export default class MyComponent extends JSXComponent<MyComponentProps> {
    innerState: boolean = false;

    @Ref() rootRef! HTMLDivElement;

    @Effect()
    atomicEffect() {
      subscriber.on(() => {
        this.innerState = !this.innerState;

        this.props.onSmthHappened();
      });
    }

    @Method()
    export() {
      return pdfjs.fromHtml(this.rootRef);
    }

    onClick() {
      this.props.selected = !this.props.selected;
    }

    get childProp(): string {
      return this.innerState && this.props.selected ? "a" : "b";
    }
  }

  function viewFunction(viewModel: MyComponent) {
    const hasTemplate = !!viewModel.props.userTemplate;
    return (
      <div
        ref={viewModel.rootRef as any}
        className="my-class"
        { ...viewModel.restAttributes }
      >
        {hasTemplate &&
          <viewModel.props.template
            someProp={viewModel.childProp}
            parentRef={viewModel.rootRef}
          />
        }
        {!hasTemplate && 
          <SubComponent someProp={viewModel.childProp} onClick={viewModel.onClick} />
        }
        { viewModel.props.readonlyProp }
        { viewModel.props.namedSlot }
      </div>
    );
  }
  ```
  
</details>

Язык декларативного описания и способ организации кода имеет ряд ограничений, которые могут показаться излишними. Однако продиктовано это все тем, что система построена на пересечении фич и возможностей таргет-фреймворков. Если отойти от этих ограничений, то компоненты в разных фреймворках будут работать по-разному. 

Список ограничений неполный, будет пополняться и актуализироваться в процессе написания компонентов. 

### Model 
Для описания модели используется класс, помеченный декоратором `@ComponentBindings()`. Все поля этого класса так же помечаются нужными декораторами.

Поля модели по возможности должны быть необязательными. 

Использование конструктора не допускается. Класс служит только для описания структуры модели. Не должен иметь поведения. 

#### Декораторы пропертей класса модели 
`@OneWay()` - обычный readonly проп, пользователь компонента через него передает какие-то данные, на основе который компонент решает что и как ему отобразить во view. OneWay пропы нельзя изменять, их можно только читать (см `readonlyProp` в примере) 

`@TwoWay()` - это проп, который может быть изменен компонентом, при этом пользователь компонента получит оповещение об этом изменении. Технически в компоненте сгенерируется дополнительный Event `${propName}Change`, который не надо руками объявлять. Однако есть случаи, когда его все же надо будет объявить (будет рассмотрено в секции юзкейзов). Однако триггерить или еще что-то делать с этим ивентом в компоненте больше не надо. Запись в этот проп также приводит к циклу перерисовки компонента. См. в примере проп `selected`

`@Event()` - это колбек, который вызывает компонент, если что-то произошло. Колбек должен принимать не более 1 параметра 

`@Template()` - проп, содержащий компонент или render-функцию для кастомной отрисовки чего-либо. В делкаративном компоненте темплейтами могут быть другие декларативные компоненты. 

`@Slot()` - проп, через который можно передать некий контент для прямого отображения. В ангуляре это называется transcluded content, в реакте это просто jsx разметка, например. Если в компоненте объявлен слот с именем `default`, в него придет дочерний контент компонента из разметки пользователя компонента. (это аналог пропса `children` в React) 

### ViewModel 
Функции viewModel берет на себя сам компонент. Для описания используется класс, помеченный декоратором `@Component()` и наследующий `JSXComponent` от типа Model класса. В декораторе компонента обязательно указывается view функция, а так же опционально дополнительные параметры 
```typescript
@Component({ 
  view: viewFunction, 
  defaultOptionRules, 
  registerJQuery: true 
}) 
```
`defaultOptionRules` - правила задания дефолтных опций по девайсу (см button.tsx) 

`registerJQuery` - надо ли компонент регистрировать как виджет для jQuery. Это нужно делать только для некоторых, тех, которые пользователи будут создавать через `$().dxWidgetName()`, любые внутренние компоненты, которые используются только нами не должны быть зарегестрированы как jQuery виджеты. 

#### Декораторы членов класса компонента 
`@Ref()` - этим декоратором помечаются члены, которые должны быть ссылками на ноды либо другие компоненты. Эти члены обязательно передавать как проп `ref` компонентов или нод в разметке. См. `rootRef` в примере, а также описание рефов в реакте 

`@Effect()` - метод, в котором можно запустить императивный код, когда компонент уже в доме. См. пример, в нем организована подписка синтетическая. Аналог `useEffect` в реакте 

`@Method()` - этим декоратором помечаются методы, которые представляют внешнее АПИ компонента. Для примеров - экспорт, принт, фокус. Методы должны использоваться только в редких случаях, когда нельзя что-то решить через входные пропы, либо если надо что-то юзеру отдать, что не может быть отдано через `TwoWay` пропы и ивенты 

Так же класс компонента может содержать члены без декораторов. В этом случае они выполняют следующие роли: 

Методы - вспомогательные методы преобразования модели, хэндлеры событий и прочее 

Свойства - хранят внутреннее состояние компонента. Запись в эти свойства приводит к циклу перерисовки компонента. Пользователь не получает никаких оповещений об изменении внутреннего состояния, так же нет возможности задать его значение извне. 

Геттеры - предоставляют удобный способ задания пропертей вьюмодели. Хотя можно для этого использовать и обычные методы и в JSX разметке делать вызовы этих методов, предпочтительно использовать геттеры. Это упростит код (особенно итогового ангуляр компонента). Геттеры не должны менять состояние, или еще как-то модифицировать что-то. Их назначение - только лишь преобразовать пропы и состояние в пригодный для view вид. Думайте о них, как об аналогах чистых функций (хоть они и не принимают ничего на входе). Никаких сайдэффектов 

Использование конструктора не допускается. Наследование от других компонентов (кроме `JSXComponent`) не допускается.

Важно! Базовый `JSXComponent` содержит поле `restAttributes`, которое предоставляет возможность передать в рутовый элемент кастомные, неописанные в модели, параметры. Этот `restAttributes` необходимо заспредить в рутовый элемент во View (см далее во View). Это необходимо для корректной работы реакт компонентов. При этом, если вам зачем-то понадобилось что-то прочить из `restAttributes` и как-то обработать - это верный признак, что это что-то вам надо объявить в модели. В идеальном компоненте `restAttributes` только лишь появляются во View

Все методы (методы и геттеры) компонента должны содержать только высокоуровневую логику, напрямую оперирующую данными компонента. Любой другой код должен быть вынесен в отдельные утилиты. Особенно это относится к коду, каким-то образом относящемуся к браузерам (работа с DOM, ивентами и проч). Это нужно для легкого чтения/тестирования логики компонентов.

### View 
Для объявления view используется функция, принимающая экземпляр класса компонента и возвращающая JSX разметку. В качестве вьюмодели используется экземпляр класса компонента. Используйте его геттеры, состояние и пропы.  

Код во view должен быть как можно проще. Сложные конструкции могут привести к неверной генерации компонентов. Один из примеров switch – лучше вместо него использовать логическое операторы.  

Так же view функция — это единственное место в компоненте, где можно создавать JSX разметку. Ни в методах и геттерах вьюмодели, ни во вспомогательных функциях разметки быть не должно. Если вам кажется, что можно куда-то выделить часть разметки — значит вам надо создать новый компонент. Елси вам кажется, что компонент только лишь отрисовывающий какую-то мелочь, не имеющий состояния и поведения — это как-то плохо, то нет, это не плохо, все зависит от обстоятельств. 

Всегда предавайте `restAttributes` в рутовый эелемент (компонент это или нет) вьюхи. См. пример

# How to 
В этой секции будут даны рекомендации, советы и гайдлайны

## Жизненный цикл компонента
Хотя технически компонент записан в виде класса, лучше всего думать о нем, как о функции. Эта функция принимает на вход параметры и выдает разметку. Да, это функциональный реакт-компонент. Наш компонент в реакте представляет из себя именно функциональный компонент.

Поэтому Model это и есть входные данные, а View это вывод функции. Никаких других источников данных, знаний и проч не должно быть.

Отсюда следует, что любое именение, которое мы хотим внести в компоненте приведет к перерисовке, и компонент целиком и полностью полагается на модель.

Любое изменение TwoWay пропа нигде не сохраняется, оно заставит перерисоваться компонент, а новое значение будет в модели (и не факт, что именно то, которое Вы туда записали)

Только запись в сво-ва самого комопнента сохраняются в нем, но вызывают такой же новый цикл рендера.

## Компоненты 
Одно из самых главных - новый DevExtreme это набор простых, реюзабельных компонентов. Очень важно не плодить кучу одинаковых компонентов. Если вам нужен какой-то простой компонент, посмотрите, нет ли уже такого. Возможно, такой уже есть, и вы можете его использовать. Или он немного специфичен и его можно чуть-чуть видоизменить. Если его нет, то создавайте его таким, чтоб другие могли его использовать.  

Тут так же важно не делать швейцарские ножи, мощные и универсальные компоненты, с кучей пропов, которые можно использовать в многих местах, но которые будут выглядеть по-разному (ну пропов же много). Компоненты должны быть простыми, решать одну задачу. 

Например, кнопка. У кнопки одно простое предназначение, вид ее ожидаемый. Не стоит в разных больших компонентах заводить свои кнопки, просто потому что вам кажется, что она тут немного другая, имеет еще какую-то функцию. Все эти нестыковки и желания могут быть решены другими способами, например созданием компонентов высшего порядка (HOC). Вариантов много, вы все о них читали в интернетах. 

Q. Так что же, могу наследоваться от кнопки и сделать свою, с блэк джеком и куртизанками, как я всегда делал в DevExtreme? 

А. Нет. В новом DevExtreme мы отказались от наследования. Если у какого-то компонента нет нужной вам фичи и этому компоненту она не нужна - создайте новый HOC компонент, в нем отрисуйте имеющийся, пробросьте ему пропы, обработайте новые и дело готово.  

Но наследование как фича языка конечно не запрещена. В примере выше она как раз имеет место быть и очень полезна. Для чего? Классы модели, в случае такого вот построения HOC компонента, удобно наследовать от оборачиваемого компонента. Сделано это для того, чтобы не переобъявлять заново всю модель. 

Пример наследования модели и ненаследования, а включения компонентов уже есть. Все главные компоненты (те, которые были и будут зарегистрированы как jQuery виджеты) устроены таким образом, что наследуют модель от главного виджета, а свой контент рисуют как children этого виджета. 

См button.tsx в нашей базе. Button не наследует Widget, однако весь функционал виджета теперь есть в кнопке. 

Это один из примеров. 

## Разметка и стили 
При реновировании какого-либо компонента старайтесь сохранять HTML структуру, это позволит по максимуму утилизировать имеющиеся стили. Но здесь кроется подводный камень. При выделении мелких компонентов, в итоговой разметке Angular компонентов появятся промежуточные кастомные теги (вы их все помните, dx-button, dx-list-item и прочие), тогда как в React, Vue, jQuery их не будет, будут обычные дивы. 

Поэтому стоит особое внимание обращать на существующие стили, чтобы в них не было правил, полагающихся на структуру тегов разметки. Используйте классы. 

Отсюда же естественный вывод - в реюзабельных компонентах имена классов не должны отсылать к чему-то большему, они должны относиться только к этому компоненту. Внешний компонент при необходимости сможет перекрыть/изменить стили внутреннего компонента. 

## Еще пара слов о модели 
Очень важно, чтобы модель была описана целиком и полностью, не допускается каких-то неявных расширений, неописанных параметров. В реакте можно неописанные пропы передавать в компонент, а в ангуляре нельзя - отсюда такое ограничение. 

Так же старайтесь не делать обязательных параметров в модели. Это может привести к нежелательному и неочевидному поведению, а так же к разному поведению в разных фреймворках. Вы можете указать дефолтное значение любого параметра, поэтому нет необходимости в обязательных параметрах.

## Код 
Реновированный DevExtreme написан на typescript. Это значит, что надо четко указывать типы, никаких any без надобности.  

Не сохраняйте `this` в `that`, вообще под `this` должен скрываться только компонент, не переключайте контекст, используйте стрелочные функции. 

Мы не используем jQuery, в компонентах нет места для $. Это касается и нашей подмены jQuery, утилит и прочего.

Ранее уже написано, код компонента должен содержать только логику, необходимую для работы этого компонента. Если появляется сторонняя логика - это либо признак того, что нужно компонент занимается не одним каким-то делом и нужно выделить еще какой-то компонент. Либо вы пишете утилитную логику, которая должна быть выделена в отдельную утилиту и протестирована отдельно от логики компонента.

Особенно это касается работой с DOM и прочими браузерными штучками.

Опять же, все утилиты (и прочий общий код) должны быть реюзабельными, не стоит плодить один и тот же функционал, завернутый в разный код.

## Тестирование
Одно из важных условий это 100% code coverage. Вся логика компонента, view, должны быть протестированы. 

Тестировать надо не конечные нагенеренные компоненты во всех фреймворках, а декларативные компоненты, только их логика и код.

Вот почему весь лишний код надо выносить из компонентов и тестировать отдельно. Этот код может потребовать наличия браузеров в тестовой системе, еще какие-то вещи.

Быстрые, легкие и понятные юнит-тесты - основа тестирования, гарантия стабильной работы всех компонентов.

Система тестирования, облегчающая написание и построение тестов, еще находится в разработке.

Этот пункт еще будет дополняться.

## Обратная совместимость 
Мы не можем отказаться от многого, что есть в текущем DevExtreme, поэтому что-то в декларации будет выглядеть лишним, какие-то фичи фреймворков нельзя использовать.  

Сколько это продлится - вопрос открытый, но пока мы с этим живем. 

Примеры: 

### Подписка на ивенты 
Мы не можем использовать нативные ивенты фреймворков. Мы могли бы подписаться на `click` ивент прям в JSX разметке и иметь нативные ивенты в каждом фреймворке. Но мы должны поддержать наши старые dxEvents. Поэтому все подписки на ивенты совершайте из эффектов (`@Effect()`). См. примеры в renovation/button.tsx и renovation/widget.tsx 

### Темплейты 
Для поддержки старого поведения в jQuery виджетах необходимо в темплейты передавать реф на ноду, в которой будет рисоваться темплейт. Реф надо объявить, указать в разметке и передать в темплейт (как проп `parentRef`). Выглядит это лишним, когда смотришь на компонент. 
```jsx
<div ...> 
  … 
  <div ref={viewModel.templateRef} > 
    {viewModel.template &&  
      <viewModel.template 
        parentRef={viewModel.templateRef} 
        someProp={viewModel.someProp} /> 
    } 
    {!viewModel.template && 
      <div>Default content</div> 
    } 
  </div> 
</div> 
```
Также из примера выше видно, что дефолтных темплейтов теперь нет. Проп темплейт теперь содержит только переданный извне темплейт. Никакого хранилища дефолтных темплейтов нет. Любой дефолтный вид компонента теперь не в темплейте, а прямо во view функции. Но можно, конечно, завести небольшой компонент и рисовать его, если нет темплейта. 

### registerKeyHandler 
Для поддержки корректной работы этого метода в jQuery виджетах, в декларативных виджетах надо добавить onKeyDown ивент и правильно его обработать. 

Корневой компонент (Widget.tsx) уже имеет такой ивент, райзит его на нажатии любой клавиши клавиатуры. В вашем компоненте надо на него подписаться, и делать свои действия (если вашему компоненту надо что-то делать при нажатии на клавиши). Однако сначала вам надо вызвать свой проп-ивент `onKeyDown`, и если он вернет `cancel == true`, то не вполнять свое действие. 

См `onWidgetKeyDown` в Button.tsx 
```typescript
onWidgetKeyDown(event: Event, options) { 
  const { onKeyDown } = this.props; 
  const { keyName, which } = options; 
 
  const result = onKeyDown?.(event, options); 
  if (result?.cancel) { 
    return result; 
  } 
 
  if (...) { 
    event.preventDefault(); 
    this.onWidgetClick(event); 
  } 
} 
```
