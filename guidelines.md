# DevExtreme - Declaration Guidelines

Описание подхода создания нативных компонентов.

## Содержание

- [Цели](#цели)
- [Принципы](#принципы)
- [Декларатвные компоненты](#декларативные-компоненты)
- - [Описание компонента](#описание-компонента)
- - [Model](#model)
- - [ViewModel](#viewmodel)
- - [View](#view)
- [Рекомендации](#Рекомендации)
- - [Код](#Код)
- - [Компоненты](#компоненты)
- - [Тестирование](#Тестирование)
- - [Жизненный цикл компонента](#Жизненный-цикл-компонента)
- - [Описание пропов](#Описание-пропов)
- - [Разметка и стили](#разметка-и-стили)
- - [Использование необъявленных атрибутов](#Использование-необъявленных-атрибутов)
- [Обратная совместимость](#Обратная-совместимость)
- - [Подписка на ивенты](#Подписка-на-ивенты)
- - [Темплейты](#Темплейты)
- - [registerKeyHandler](#registerKeyHandler)
- [Разработка](#разработка)
## Цели

Обеспечение высокого уровня качества. Код должен быть простым, стабильным, быстрым, отвечать современным стандартам разработки и сопровождения.

Обеспечение выпуска нативных компонентов под разные фреймворки на основе единой кодовой базы - мы не должны повторно разрабатывать компоненты для разных фреймворков (существующих и новых).

## Принципы

Для достижения целей было решено разработать систему декларативных компонентов и генераторов.

Разработчик декларативно описывает компонент, набор генераторов преобразует эту декларацию в нативные компоненты для разных фреймворков.

## Декларативные компоненты

В основу описания декларативных компонентов взята MVVM модель и React-компоненты.

Компонент представляет собой:
- Model - описание входных данных;
- View - представление, HTML разметка в JSX;
- ViewModel - правила преобразования и взаимодействия Model и View реализованные в виде некоего подобия React-компонента.

### Описание компонента

Язык декларативного описания и способ организации кода имеет ряд ограничений, которые могут показаться излишними. Однако, продиктовано это тем, что система построена на пересечении возможностей таргет-фреймворков. Если отойти от этих ограничений, то компоненты в разных фреймворках будут работать по-разному.

Список ограничений неполный, будет пополняться и актуализироваться в процессе написания компонентов. 

<details>
  <summary>Пример компонента</summary>
  
  ```tsx
  import { 
    Component,
    ComponentBindings,
    Effect,
    Event, 
    JSXComponent, 
    Method,
    OneWay, 
    Ref,
    Slot,
    Template, 
    TwoWay 
  } from 'devextreme-generator/component_declaration/common';
  import SubComponent from './SubComponent';
  import { subscriber } from './utils/subscriber';
  import pdfjs from 'pdfjs';

  @ComponentBindings()
  export class MyComponentProps {
    @OneWay() readonlyProp?: string = "default value";
    @TwoWay() selected? boolean = false;
    @Event() onSmthHappened?: () => void;
    @Template() userTemplate?: any;
    @Slot() namedSlot?: any;
  }

  @Component({
    view: viewFunction
  })
  export default class MyComponent extends JSXComponent<MyComponentProps> {
    innerState: boolean = false;

    @Ref() rootRef! HTMLDivElement;

    @Effect()
    atomicEffect() {
      subscriber.on(() => {
        this.innerState = !this.innerState;

        this.props.onSmthHappened();
      });
    }

    @Method()
    export() {
      return pdfjs.fromHtml(this.rootRef);
    }

    onClick() {
      this.props.selected = !this.props.selected;
    }

    get childProp(): string {
      return this.innerState && this.props.selected ? "a" : "b";
    }
  }

  function viewFunction(viewModel: MyComponent) {
    const hasTemplate = !!viewModel.props.userTemplate;
    return (
      <div
        ref={viewModel.rootRef as any}
        className="my-class"
        { ...viewModel.restAttributes }
      >
        {hasTemplate &&
          <viewModel.props.template
            someProp={viewModel.childProp}
            parentRef={viewModel.rootRef}
          />
        }
        {!hasTemplate && 
          <SubComponent someProp={viewModel.childProp} onClick={viewModel.onClick} />
        }
        { viewModel.props.readonlyProp }
        { viewModel.props.namedSlot }
      </div>
    );
  }
  ```
  
</details>

#### Model

Для описания модели используется класс, помеченный декоратором `@ComponentBindings()`. Все поля этого класса так же помечаются нужными декораторами.

Поля модели по возможности должны быть необязательными. 

Использование конструктора не допускается. Класс служит только для описания структуры модели. Не должен иметь поведения. 

##### Декораторы членов класса

- `@OneWay()` - обеспечивает одностороннюю связь данных. Служит для передачи данных, на основе которых компонент решает, что и как ему отобразить во view. OneWay пропы нельзя изменять, их можно только читать (см `readonlyProp` в примере);

- `@TwoWay()` - обеспечивает двустороннюю связь данных. Может быть изменен компонентом, при этом пользователь компонента получит оповещение об этом изменении через дополнительно сгенерённый Event. Технически, в компоненте сгенерируется дополнительный Event `${propName}Change` автоматически. Однако, есть случаи, когда его все же надо будет объявить (будет рассмотрено в секции юзкейзов). Его обновление также приводит к циклу перерисовки компонента. См. в примере проп `selected`;

- `@Event()` - это колбек, который вызываетется компонентом, при возникновении определенного события. Колбек должен принимать не более 1 параметра;

- `@Template()` - проп, содержащий компонент или render-функцию для кастомной отрисовки контента. В делкаративном компоненте темплейтами могут быть другие декларативные компоненты;

- `@Slot()` - проп, через который можно передать некий контент для прямого отображения. В ангуляре это называется transcluded content, в реакте это просто jsx разметка, например. Если в компоненте объявлен слот с именем `default`, в него придет дочерний контент компонента из разметки пользователя компонента. (это аналог пропса `children` в React.

#### ViewModel

Для описания ViewModel используется класс, помеченный декоратором `@Component()` и наследующий `JSXComponent` от класса Model. В декораторе компонента обязательно указывается view функция, а так же опционально дополнительные параметры

```typescript
@Component({ 
  view: viewFunction, 
  defaultOptionRules, 
  registerJQuery: true 
}) 
```

- `view` - чистая функция, возвращающая HTML разметку. Её аргументом является объект, содержащий члены класса `ViewModel` и объект **props**, содержащий члены класса `Model`;

- `defaultOptionRules` - правила задания дефолтных пропертей относительно девайса (см button.tsx);

- `registerJQuery` - определяет будет ли компонент регистрирован как jQuery виджет. Это нужно делать только для компонентов, которые будут создаваться через `$().dxWidgetName()`.

##### Декораторы членов класса

- `@Ref()` - декоратором помечаются члены, которые являются ссылками на ноды либо другие компоненты. Эти члены обязательно передавать как проп `ref` компонентов или нод в разметке (`<div ref={myRef} />`). См. `rootRef` в примере, а также [описание рефов в реакте](https://ru.reactjs.org/docs/refs-and-the-dom.html);

-  `@Effect()` - метод, в котором можно запустить код для работы с DOM и только в нём! См. пример, в нем организована синтетическая подписка на DOM элемент. Аналог [useEffect в реакте](https://ru.reactjs.org/docs/hooks-reference.html#useeffect);

- `@Method()` - этим декоратором помечаются методы, которые представляют внешнее АПИ компонента. Для примеров - экспорт, принт, фокус. Методы должны использоваться только в редких случаях, когда нельзя что-то решить через входные пропы, либо если надо что-то юзеру отдать, что не может быть отдано через `@TwoWay` пропы и ивенты.

Так же класс компонента может содержать члены без декораторов: 

- `Методы` - вспомогательные методы преобразования модели, хэндлеры событий и прочее;

- `Свойства` - хранят внутреннее состояние компонента. Запись в эти свойства приводит к циклу перерисовки компонента. Пользователь не получает никаких оповещений об изменении внутреннего состояния, так же нет возможности задать его значение извне;

- `Геттеры` - предоставляют удобный способ задания пропертей вьюмодели. Хотя можно для этого использовать и обычные методы и в JSX разметке делать вызовы этих методов, предпочтительно использовать геттеры. Это упростит код (особенно итогового ангуляр компонента). Геттеры не должны менять состояние, или еще как-то модифицировать что-то. Их назначение - только лишь преобразовать пропы и состояние в пригодный для `view` вид. Думайте о них, как об аналогах чистых функций (хоть они и не принимают ничего на входе). Никаких сайдэффектов.

Использование конструктора не допускается. Наследование от других компонентов (кроме `JSXComponent`) не допускается.

Все методы (методы и геттеры) компонента должны содержать только высокоуровневую логику, напрямую оперирующую данными компонента. Любой другой код должен быть вынесен в отдельные утилиты. Особенно это относится к коду, каким-то образом относящемуся к браузерам (работа с DOM, ивентами и проч). Это нужно для легкого чтения/тестирования логики компонентов.

**Важно!** Базовый `JSXComponent` содержит поле `restAttributes`, которое предоставляет возможность передать в рутовый элемент кастомные, неописанные в модели, параметры. См [Использование необъявленных атрибутов](#Использование-необъявленны-атрибутов)

#### View

Для объявления `view` используется функция, принимающая экземпляр класса компонента и возвращающая JSX разметку. В качестве `viewModel` используется экземпляр класса компонента, помеченного декоратором `@Component()`. Используйте его геттеры, состояние и пропы.

Код во view должен быть максимально простым. Сложные конструкции могут привести к неверной генерации компонентов. Один из примеров switch – лучше вместо него использовать логическое операторы.

Так же view функция — это единственное место в компоненте, где можно создавать JSX разметку. Ни в методах и геттерах вьюмодели, ни во вспомогательных функциях разметки быть не должно. Если вам кажется, что можно куда-то выделить часть разметки — значит вам надо создать новый компонент. Елси вам кажется, что компонент только лишь отрисовывающий какую-то мелочь, не имеющий состояния и поведения — это как-то плохо, то нет, это не плохо, все зависит от обстоятельств. 

## Рекомендации

### Код

Реновированный DevExtreme написан на typescript. Это значит, что надо четко указывать типы, никаких `any`.  

Не сохраняйте `this` в `that`, вообще под `this` должен скрываться только компонент, не переключайте контекст, используйте стрелочные функции. 

Мы не используем jQuery, в компонентах нет места для `$`. Это касается и нашей подмены jQuery, утилит и прочего.

Ранее уже написано, код компонента должен содержать только логику, необходимую для работы этого компонента. Если появляется сторонняя логика - это либо признак того, что нужно компонент занимается не одним каким-то делом и нужно выделить еще какой-то компонент. Либо вы пишете утилитную логику, которая должна быть выделена в отдельную утилиту и протестирована отдельно от логики компонента.

Особенно это касается работой с DOM и прочими браузерными штучками.

Опять же, все утилиты (и прочий общий код) должны быть реюзабельными, не стоит плодить один и тот же функционал, завернутый в разный код.

### Компоненты

**Одно из самых главных - создать набор простых, реюзабельных компонентов.** Если вам нужен какой-то простой компонент, посмотрите, нет ли уже существующего. Возможно, такой уже есть, и вы можете его использовать. Или он немного специфичен и его можно чуть-чуть видоизменить. Если его нет, то создавайте его таким, чтоб другие могли его использовать.  

Тут так же важно не делать швейцарские ножи, мощные и универсальные компоненты, с кучей пропов, которые можно использовать в многих местах, но которые будут выглядеть по-разному (ну пропов же много). **Компоненты должны быть простыми, решать одну задачу.**

Например, кнопка. У кнопки одно простое предназначение, вид ее ожидаемый. Не стоит в разных больших компонентах заводить свои кнопки, просто потому что вам кажется, что она тут немного другая, имеет еще какую-то функцию. Все эти нестыковки и желания могут быть решены другими способами, например созданием компонентов высшего порядка (HOC). Вариантов много, вы все о них читали в интернетах. 

Q. Так что же, могу наследоваться от кнопки и сделать свою, с блэк джеком и куртизанками, как я всегда делал в DevExtreme? 

А. Нет. В новом DevExtreme мы отказались от наследования. Если у какого-то компонента нет нужной вам фичи и этому компоненту она не нужна - создайте новый HOC компонент, в нем отрисуйте имеющийся, пробросьте ему пропы, обработайте новые и дело готово.  

Но наследование как фича языка конечно не запрещена. В примере выше она как раз имеет место быть и очень полезна. Для чего? Классы модели, в случае такого вот построения HOC компонента, удобно наследовать от оборачиваемого компонента. Сделано это для того, чтобы не переобъявлять заново всю модель. 

Пример наследования модели и включения компонентов (а не прямое наследование) уже есть. Все главные компоненты (те, которые были и будут зарегистрированы как jQuery виджеты) устроены таким образом, что наследуют модель от главного виджета, а свой контент рисуют как children этого виджета. 

См button.tsx в нашей базе. Button не наследует Widget, однако весь функционал виджета теперь есть в кнопке.

### Тестирование

Одно из важных условий это 100% code coverage. Вся логика компонента, view, должны быть протестированы. 

Тестировать надо не конечные нагенеренные компоненты во всех фреймворках, а декларативные компоненты, только их логику и код.

Вот почему весь лишний код надо выносить из компонентов и тестировать отдельно. Этот код может потребовать наличия браузеров в тестовой системе, еще какие-то вещи.

Быстрые, легкие и понятные юнит-тесты - основа тестирования, гарантия стабильной работы всех компонентов.

Система тестирования, облегчающая написание и построение тестов, еще находится в разработке.

Этот пункт еще будет дополняться.

### Описание пропов

Очень важно, чтобы модель была описана целиком и полностью, не допускается каких-то неявных расширений, неописанных параметров. В реакте можно неописанные пропы передавать в компонент, а в ангуляре нельзя - отсюда такое ограничение. 

Так же старайтесь не делать обязательных параметров в модели. Это может привести к нежелательному и неочевидному поведению, а так же к разному поведению в разных фреймворках. Вы можете указать дефолтное значение любого параметра, поэтому нет необходимости в обязательных параметрах.

### Жизненный цикл компонента

Хотя технически компонент записан в виде класса, лучше всего думать о нем, как о функции. Эта функция принимает на вход параметры и выдает разметку. Да, это функциональный реакт-компонент. Наш компонент в реакте представляет из себя именно функциональный компонент.

Поэтому `Model` это и есть входные данные, а `View` это вывод функции. Никаких других источников данных, знаний и прочего не должно быть.

Отсюда следует, что любое изменение пропертей, которое мы хотим внести приведет к перерисовке, и компонент целиком и полностью полагается на модель.

Любое изменение `@TwoWay` пропа нигде не сохраняется, оно заставит перерисоваться компонент, а новое значение будет в модели (и не факт, что именно то, которое Вы туда записали).

Только запись в сво-ва самого комопнента сохраняются в нем, но вызывают такой же новый цикл рендера.

### Разметка и стили

При реновировании какого-либо компонента старайтесь сохранять HTML структуру, это позволит по максимуму утилизировать имеющиеся стили. Но здесь кроется подводный камень. При выделении мелких компонентов, в итоговой разметке Angular компонентов появятся промежуточные кастомные теги (вы их все помните, dx-button, dx-list-item и прочие), тогда как в React, Vue, jQuery их не будет, будут обычные дивы. 

Поэтому стоит особое внимание обращать на существующие стили, чтобы в них не было правил, полагающихся на структуру тегов разметки. Используйте классы. 

Отсюда же естественный вывод - в реюзабельных компонентах имена классов не должны отсылать к чему-то большему, они должны относиться только к этому компоненту. Внешний компонент при необходимости сможет перекрыть/изменить стили внутреннего компонента. 

### Использование необъявленных атрибутов

Одним из преимуществ нативных компонентов является добавление любых пользовательских атрибутов в HTML разметку. В Angular и Vue это решается на стороне самих фреймворков, для поддержки в React необходимо использовать геттер `restAttributes` - его не надо объявлять, он доступен сразу в первом аргументе `view` функции.

Этот геттер возвращает объект **дополнительных** атрибутов, которые пользователь повесил на нативный компонент.

Всегда предавайте `restAttributes` в рутовый эелемент (компонент это или нет) вьюхи. См. пример.

Есть два варианта использования

1. Пробросить в одноименный проп компонента `Widget`. Внутри `Widget` сделает все сам 🤗;
2. Добавить все проперти объекта в HTML разметку с помощью spread оператора.

   ```tsx
   <div
    {...restAttributes}
   >
   </div>
   ```

## Обратная совместимость

Мы не можем отказаться от многого, что есть в текущем DevExtreme, поэтому что-то в декларации будет выглядеть лишним, какие-то фичи фреймворков нельзя использовать.  

Сколько это продлится - вопрос открытый, но пока мы с этим живем. 

### Подписка на ивенты

Мы не можем использовать нативные ивенты фреймворков. Мы могли бы подписаться на `click` ивент прям в JSX разметке и иметь нативные ивенты в каждом фреймворке. Но мы должны поддержать наши старые dxEvents. Поэтому все подписки на ивенты совершайте из `@Effect()`. См. примеры в renovation/button.tsx и renovation/widget.tsx 

### Темплейты

Для поддержки старого поведения в jQuery виджетах необходимо в темплейты передавать реф на ноду, в которой будет рисоваться темплейт. Реф надо объявить, указать в разметке и передать в темплейт (как проп `parentRef`). Выглядит это лишним, когда смотришь на компонент.

```jsx
<div ...> 
  … 
  <div ref={viewModel.templateRef} > 
    {viewModel.template &&  
      <viewModel.template 
        parentRef={viewModel.templateRef} 
        someProp={viewModel.someProp} /> 
    } 
    {!viewModel.template && 
      <div>Default content</div> 
    } 
  </div> 
</div> 
```

Также из примера выше видно, что дефолтных темплейтов теперь нет. Проп темплейт теперь содержит только переданный извне темплейт. Никакого хранилища дефолтных темплейтов нет. Любой дефолтный вид компонента теперь не в темплейте, а прямо во view функции. Но можно, конечно, завести небольшой компонент и рисовать его, если нет темплейта. 

### registerKeyHandler

Для поддержки корректной работы этого метода в jQuery виджетах, в декларативных виджетах надо добавить onKeyDown ивент и правильно его обработать. 

Корневой компонент (Widget.tsx) уже имеет такой ивент, райзит его на нажатии любой клавиши клавиатуры. В вашем компоненте надо на него подписаться, и делать свои действия (если вашему компоненту надо что-то делать при нажатии на клавиши). Однако сначала вам надо вызвать свой проп-ивент `onKeyDown`, и если он вернет `cancel == true`, то не вполнять свое действие. 

См `onWidgetKeyDown` в Button.tsx 
```typescript
onWidgetKeyDown(event: Event, options) { 
  const { onKeyDown } = this.props; 
  const { keyName, which } = options; 
 
  const result = onKeyDown?.(event, options); 
  if (result?.cancel) { 
    return result; 
  } 
 
  if (...) { 
    event.preventDefault(); 
    this.onWidgetClick(event); 
  } 
} 
```

## Разработка

Пока что разработка новых компонентов ведется в ветке [preact-button](https://github.com/DevExpress/DevExtreme/tree/preact-button). Все комопненты пока размещаются в папке [js/renovation](https://github.com/DevExpress/DevExtreme/tree/preact-button/js/renovation).

### Исходный код

Все декораторы, а так же базовый `JSXComponent` необходимо импортировать из `devextreme-generator/component_declaration/common`.

Стартовый шаблон кода компонента:
```tsx
import {
  Component,
  ComponentBindings,
  JSXComponent,
  OneWay,
} from 'devextreme-generator/component_declaration/common';

export const viewFunction = (viewModel: Component) => {
  return (<div></div>);
};

@ComponentBindings()
export class ComponentProps {
  // Your props go here
}

@Component({
  view: viewFunction,
})
export default class Component extends JSXComponent<ComponentProps> {
  // ViewModel getters, Effects, Refs, go here  
}
```

Так же смотрите пример выше в этом гайде, а так же уже реализованные компоненты в `js/renovation`.

### Тестирование компонентов

Тесты на декларации написаны с использование jest. Примеры тестов на существующие компоненты см в [testing/jest](https://github.com/DevExpress/DevExtreme/tree/preact-button/testing/jest).

Для подготовки (компиляции) компонентов к тестированию, необходимо воспользоваться тасками `test-env`, `dev`, либо gulp таской `generate-components`. Рядом с вашим декларативных компонентом появится файл с расширением .p.js. (Это Preact компонент, скомпилированный из декларативного. Пока что он используется для тестирования)

Так же ознакомьтесь с информацией в [Тестирование](#тестирование)

!! Раздел дополняется

### Playground

В папке playground есть приложения на ангуляре и реакте, показывающие новую кнопку

Для того, чтобы можно было посмотреть вживую на работу компонента в плейграунде его нужно скомпилировать под нужный фреймворк. Воспользуйтесь билдежными тасками

React - `build:react` либо `build:react:watch`

Angular - `build:angular` либо `build:angular:watch`

jQuery - если в декораторе Вашего компонента указано `registerJQuery: true`, то при запуске тасок `build`, `dev`, `test-env` в дополнение к Preact-компоненту сгенерируется и jQuery враппер над ним. Имя для jQuery-виджета совпадает с именем компонента (без приставки `dx`).
