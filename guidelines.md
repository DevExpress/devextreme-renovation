# DevExtreme - Declaration Guidelines

Описание подхода создания нативных компонентов.

## Содержание

- [Цели](#цели)		
- [Принципы](#принципы)		
- [Декларативные компоненты](#декларативные-компоненты)		
  - [Описание компонента](#описание-компонента)		
    - [Model](#model)		
      - [Декораторы членов класса](#декораторы-членов-класса)		
    - [ViewModel](#viewmodel)		
      - [Декораторы членов класса](#декораторы-членов-класса-1)		
    - [View](#view)		
- [Рекомендации](#рекомендации)		
  - [Код](#код)		
  - [Компоненты](#компоненты)		
  - [Тестирование](#тестирование)		
  - [Описание пропов](#описание-пропов)		
  - [Жизненный цикл компонента](#жизненный-цикл-компонента)		
  - [Разметка и стили](#разметка-и-стили)		
  - [Использование необъявленных атрибутов](#использование-необъявленных-атрибутов)		
- [Обратная совместимость](#обратная-совместимость)		
  - [Значения для TwoWay пропов](#значения-для-twoway-пропов)		
  - [Подписка на ивенты](#подписка-на-ивенты)		
  - [Ивенты комопнентов](#ивенты-комопнентов)		
  - [Темплейты](#темплейты)		
  - [registerKeyHandler](#registerkeyhandler)		
- [Разработка](#разработка)		
  - [Именование и структура файлов, папок](#именование-и-структура-файлов-папок)		
  - [Исходный код](#исходный-код)		
  - [jQuery](#jquery)		
  - [Тестирование компонентов](#тестирование-компонентов)		
  - [Playground](#playground)		
  - [Оформление багов](#оформление-багов)
  - [Ограничения](#ограничения)
  - [Use Cases](#use-cases)		
    - [@OneWay()](#oneway)		
    - [@TwoWay()](#twoway)	
    - [@Nested()](#nested)			
    - [@Event()](#event)		
    - [@Ref()](#ref)		
    - [@ForwardRef()](#forwardref)		
    - [@Effect()](#effect)		
    - [@Template()](#template)	
    - [@Slot()](#slot)		
    - [@Method()](#method)	
    - [Context](#context)	
    - [JSX](#jsx)
    - [Portals](#portals)
    - [Динамические компонеты](#динамические-компоненты)

## Цели

Обеспечение высокого уровня качества. Код должен быть простым, стабильным, быстрым, отвечать современным стандартам разработки и сопровождения.

Обеспечение выпуска нативных компонентов под разные фреймворки на основе единой кодовой базы - мы не должны повторно разрабатывать компоненты для разных фреймворков (существующих и новых).

## Принципы

Для достижения целей было решено разработать систему декларативных компонентов и генераторов.

Разработчик декларативно описывает компонент, набор генераторов преобразует эту декларацию в нативные компоненты для разных фреймворков.

## Декларативные компоненты

В основу описания декларативных компонентов взята *MVVM* модель и *React*-компоненты.

Компонент представляет собой:

- *Model* - описание входных данных;
- *View* (*View*-функция) - представление, *HTML* разметка в *JSX*;
- *ViewModel* - правила преобразования и взаимодействия *Model* и *View* реализованные в виде некоего подобия *React*-компонента.

### Описание компонента

Язык декларативного описания и способ организации кода имеют ряд ограничений, которые могут показаться излишними. Однако, продиктовано это тем, что система построена на пересечении возможностей *target*-фреймворков. Если отойти от этих ограничений, то компоненты в разных фреймворках будут работать по-разному.

Список ограничений неполный, будет пополняться и актуализироваться в процессе написания компонентов.

<details>
  <summary>Пример компонента</summary>

  ```tsx
  import {
    Component,
    ComponentBindings,
    Effect,
    Event,
    JSXComponent,
    Method,
    OneWay,
    Ref,
    Slot,
    Template,
    TwoWay
  } from 'devextreme-generator/component_declaration/common';
  import SubComponent from './SubComponent';
  import { subscriber } from './utils/subscriber';
  import pdfjs from 'pdfjs';

  @ComponentBindings()
  export class MyComponentProps {
    @OneWay() readonlyProp: string = "default value";
    @TwoWay() selected: boolean = false;
    @Event() onSmthHappened?: () => void;
    @Template() userTemplate: any;
    @Slot() namedSlot: any;
  }

  @Component({ view: viewFunction })
  export default class MyComponent extends JSXComponent(MyComponentProps) {
    innerState: boolean = false;

    @Ref() rootRef! HTMLDivElement;

    @Effect()
    atomicEffect() {
      const id = subscriber.on(() => {
        this.innerState = !this.innerState;

        this.props.onSmthHappened();
      });
      return () => subscriber.off(id)
    }

    @Method()
    export() {
      return pdfjs.fromHtml(this.rootRef);
    }

    onClick() {
      this.props.selected = !this.props.selected;
    }

    get childProp(): string {
      return this.innerState && this.props.selected ? "a" : "b";
    }
  }

  function viewFunction(viewModel: MyComponent) {
    const hasTemplate = !!viewModel.props.userTemplate;
    return (
      <div
        ref={viewModel.rootRef as any}
        className="my-class"
        { ...viewModel.restAttributes }
      >
        {hasTemplate &&
          <viewModel.props.template
            data={{
              someProp: viewModel.childProp
            }}
          />
        }
        {!hasTemplate &&
          <SubComponent someProp={viewModel.childProp} onClick={viewModel.onClick} />
        }
        { viewModel.props.readonlyProp }
        { viewModel.props.namedSlot }
      </div>
    );
  }
  ```

</details>

#### Model

Для описания модели используется помеченный декоратором `@ComponentBindings()` класс. Все поля этого класса также помечаются необходимыми декораторами.

Поля модели, по возможности, должны быть необязательными.

Использование конструктора не допускается. Класс служит только для описания структуры модели и не должен иметь поведения.

##### Декораторы членов класса

- `@OneWay()` - обеспечивает одностороннюю связь данных. Служит для передачи данных, на основе которых компонент решает, что и как ему отобразить во *View*. *OneWay* пропы нельзя изменять, их можно только читать (см `readonlyProp` в [примере](#Описание-компонента));

- `@TwoWay()` - обеспечивает двустороннюю связь данных. Может быть изменен компонентом, при этом пользователь компонента получит оповещение об этом изменении через дополнительно сгенерированный *change*-ивент. Технически, в компоненте автоматически сгенерируется дополнительный *event* `${propName}Change`. Однако, есть случаи, когда его все же необходимо объявить (будет рассмотрено в секции [юзкейзов](#use-cases)). Его обновление также приводит к циклу перерисовки компонента. См. в [примере](#Описание-компонента) проп `selected`;

- `@Event()` - это колбек, который вызывается компонентом, при возникновении определенного события. Колбек должен принимать не более 1 параметра;

- `@Template()` - проп, содержащий компонент или *render*-функцию для кастомной отрисовки контента. В декларативном компоненте темплейтами могут быть другие декларативные компоненты либо функции, возвращающие разметку;

- `@Slot()` - проп, через который можно передать некий контент для прямого отображения. В *Angular* это называется *transcluded content*, в *React* это просто *JSX* разметка. Если в компоненте объявлен слот с именем `children`, в него придет дочерний контент компонента из разметки пользователя компонента. Это аналог `children` в *React*.

- `@Nested()` - генерирует `OneWay` проп, который может брать значение как из пропсы объекта, так и из `children` компонентов. Для `jQuery` работает только пропса. Для корректной работы эта пропса должна быть объявлена как необязательная и без дефолтного значения. В качестве Nested пропсы может использоваться любой другой класс с декоратором `@BindingComponent()`.

  **Важно!** Если используемый компонент лежит в другом файле, необходимо его экспортировать. Без экспорта компонента, генератор не сможет его заимпортить. Также важно учитывать, что пропса имеет приоритет над компонентами.

  Имя сгенерированных компонентов основано на имени пропсы (префикс в Angular зависит от того массив ли это объектов (i - iterable), или одиночный объект (o - object)):
  |Property Name|isArray|React|Angular|Vue|
  |:---:|:---:|:---:|:---:|:---:|
  Columns|YES|Column|dxi-column|DxColumn
  GridEditing|NO|GridEditing|dxo-grid-editing|DxGridEditing

#### ViewModel

Для описания *ViewModel* используется класс, помеченный декоратором `@Component()` и наследующий `JSXComponent` от класса *Model*. В декораторе компонента обязательно указывается *View*-функция, а также опционально дополнительные параметры.

```typescript
@Component({
  view: viewFunction,
  defaultOptionRules,
  jQuery: {
    register: true,
    component: BaseComponent
  }
})
```

- `view` - чистая функция, возвращающая *HTML* разметку. Её аргументом является объект, содержащий члены класса `ViewModel` и объект **props**, содержащий члены класса *Model*;

- `defaultOptionRules` - правила задания дефолтных пропертей относительно девайса (см [*button.tsx*](https://github.com/DevExpress/DevExtreme/blob/20_2/js/renovation/button.tsx));

- `jQuery` - настройки для генерации *jQuery* виджета.

  - `register` - определяет будет ли компонент зарегистрирован как *jQuery* виджет. Это нужно делать только для компонентов, которые будут создаваться через `$().dxWidgetName()`.

  - `component` - базовый компонент для *jQuery* обертки. В общем случае ничего дополнительного для генерации *jQuery* обертки для компонента не требуется. Однако в редких случая может понадобиться дополнить базовую обертку (`js/renovation/preact-wrapper/component`) чем-то специфичным только для конкретного компонента - в этом случае необходимо создать промежуточный базовый виджет и указать его в декларации для компонента.

##### Декораторы членов класса

- `@Ref()` - декоратором помечаются члены, которые являются ссылками на ноды либо другие компоненты. Эти члены обязательно передавать как проп `ref` компонентов или нод в разметке (`<div ref={myRef} />`). См. `rootRef` в [примере](#Описание-компонента), а также [описание рефов в React](https://ru.reactjs.org/docs/refs-and-the-dom.html);

- `@Effect()` - метод, в котором можно запустить код для работы с *DOM* и только в нём! См. [пример](#Описание-компонента), в нем организована синтетическая подписка на *DOM* элемент. Аналог [useEffect в реакте](https://ru.reactjs.org/docs/hooks-reference.html#useeffect);

- `@Method()` - этим декоратором помечаются методы, которые представляют внешнее *API* компонента. Для примеров - экспорт, принт, фокус. Методы должны использоваться только в редких случаях, когда нельзя что-то решить через входные пропы, либо если надо что-то юзеру отдать, что не может быть отдано через `@TwoWay` пропы и ивенты.

Также класс компонента может содержать члены без декораторов:

- `Методы` - вспомогательные методы преобразования модели, хэндлеры событий и прочее;

- `Свойства` - хранят внутреннее состояние компонента. Запись в эти свойства приводит к циклу перерисовки компонента. Пользователь не получает никаких оповещений об изменении внутреннего состояния, также нет возможности задать его значение извне;

- `Геттеры` - предоставляют удобный способ задания пропертей *ViewModel*. Хотя можно для этого использовать и обычные методы, делать в *JSX* разметке вызовы этих методов, предпочтительно использовать геттеры. Это упростит код (особенно итогового *Angular* компонента). Геттеры не должны менять состояние, или еще как-то модифицировать что-то. Их назначение - преобразовать пропы и состояние в пригодный для *View* вид. Думайте о них, как об аналогах чистых функций (хоть они и не принимают ничего на входе). Никаких сайдэффектов.

Использование конструктора не допускается. Наследование от других компонентов (кроме `JSXComponent`) не допускается.

Все методы и геттеры компонента должны содержать только высокоуровневую логику, напрямую оперирующую данными компонента. Любой другой код должен быть вынесен в отдельные утилиты. Особенно это относится браузеро/платформенно зависимому коду (работа с *DOM*, ивентами и проч). Это нужно для легкого чтения/тестирования логики компонентов.

**Важно!** Базовый `JSXComponent` содержит поле `restAttributes`, которое предоставляет возможность передать в рутовый элемент кастомные, неописанные в модели, параметры. См [Использование необъявленных атрибутов](#Использование-необъявленных-атрибутов)

#### View

Для объявления *View* используется функция, принимающая экземпляр класса компонента и возвращающая *JSX* разметку. В качестве *ViewModel* используется экземпляр класса компонента, помеченного декоратором `@Component()`. Используйте его геттеры, состояние и пропы.

Код во *View* должен быть максимально простым. Сложные конструкции могут привести к неверной генерации компонентов. Один из примеров - *switch*. Вместо него предпочтительнее использовать логические операторы.

*View*-функция — это также единственное место в компоненте, где можно создавать *JSX* разметку. Ни в методах, ни в геттерах *ViewModel*, ни во вспомогательных функциях разметки быть не должно. Если вам кажется, что можно куда-то выделить часть разметки — значит вам надо создать новый компонент. Нет ничего плохого в визуальном компоненте, который отвечает только за рендер, не имеющем состояния и поведения.

Также возвращаемая разметка из *View* должна содержать 1 рутовый элемент. Если вам необходимо вернуть несколько, оберните их в специальный элемент `Fragment` (см. [Use cases](#JSX))

## Рекомендации

### Код

Реновированный *DevExtreme* написан на *typescript*. Это значит, что надо четко указывать типы, никаких `any`.

Не сохраняйте `this` в `that`, вообще под `this` должен скрываться только компонент, не переключайте контекст, используйте стрелочные функции.

Мы не используем *jQuery*, в компонентах нет места для `$`. Это касается и нашей подмены *jQuery*, утилит и прочего.

Ранее уже написано - код компонента должен содержать только логику, необходимую для работы этого компонента. Если появляется сторонняя логика - это либо признак того что компонент необходимо разбить на несколько компонентов, либо что вы пишете утилитную логику, которая должна быть выделена в отдельную утилиту и протестирована отдельно от логики компонента.

Особенно это касается работой с *DOM* и прочими браузерными штучками.

Опять же, все утилиты (и прочий общий код) должны быть реюзабельными, не стоит плодить одну и ту же функциональность, завернутую в разный код.

### Компоненты

**Одно из самых главных - создать набор простых, реюзабельных компонентов.** Если вам нужен какой-то простой компонент, посмотрите, нет ли уже существующего. Возможно, такой уже есть, и вы можете его использовать. Возможно он немного специфичен и его необходимо чуть-чуть видоизменить. Если его нет, то создавайте его таким, чтоб другие могли его использовать.

Тут также важно не делать швейцарские ножи, мощные и универсальные компоненты, с кучей пропов, которые можно использовать в многих местах, но которые будут выглядеть по-разному (ну пропов же много). **Компоненты должны быть простыми, решать одну задачу.**

Например, кнопка. У кнопки одно простое предназначение, вид ее ожидаемый. Не стоит в разных больших компонентах заводить свои кнопки, просто потому что вам кажется, что она тут немного другая, имеет еще какую-то функцию. Все эти нестыковки и желания могут быть решены другими способами, например созданием компонентов высшего порядка (*HOC*). Вариантов много, вы все о них читали в интернетах.

Q. Так что же, могу наследоваться от кнопки и сделать свою, с блэк джеком и куртизанками, как я всегда делал в *DevExtreme*?

А. Нет. В новом *DevExtreme* мы отказались от наследования. Если у какого-то компонента нет нужной вам фичи и этому компоненту она не нужна - создайте новый *HOC* компонент, в нем отрисуйте имеющийся, пробросьте ему пропы, обработайте новые и дело готово.

Но наследование как фича языка конечно не запрещена. В примере выше она как раз имеет место быть и очень полезна. Для чего? Классы модели, в случае такого вот построения *HOC* компонента, удобно наследовать от оборачиваемого компонента. Сделано это для того, чтобы не переобъявлять заново всю модель.

Пример наследования модели и включения компонентов (а не прямое наследование) уже есть. Все главные компоненты (те, которые были и будут зарегистрированы как *jQuery* виджеты) устроены таким образом, что наследуют модель от главного виджета, а свой контент рисуют как *children* этого виджета.

См [*button.tsx*](https://github.com/DevExpress/DevExtreme/blob/20_2/js/renovation/button.tsx) в нашей базе. *Button* не наследует *Widget*, однако вся функциональность виджета теперь есть в кнопке.

### Тестирование

Одно из важных условий это 100% code coverage. Вся логика компонента, *View*, должны быть протестированы. Быстрые, легкие и понятные unit-тесты - основа тестирования, гарантия стабильной работы всех компонентов.

Тестируются не конечные нагенеренные компоненты во всех фреймворках, а декларативные компоненты (.tsx).

Весь дополнительный код (хелперы, утилиты) надо выносить из компонентов и тестировать отдельно.

Структура тестов

- Render
- Behavior
- - Effects
- - Methods
- - Events
- Logic
- - Getters
- - Default Option Rules

Ниже приведены примеры тестов. Для рендера рекомендуется использовать `shallow` вместо `mount`, как более быстрый. Также необходимо добавить `import { h } from 'preact';` в тесты и сам декларативный компонент.

<details>
  <summary>Пример компонента</summary>

  ```jsx
  describe('component_name', () => {
    describe('Render', () => {
      const render = (props) => {
        return shallow(viewFunction({ props: { ...new Component(), ...props }, /* геттеры и методы */ }));
      };

      it('should render with correct props', () => {
        const node = render();

        expect(node.prop('prop1')).toBe(100);
        expect(node.prop('prop2')).toBe(false);
        expect(node.prop('className')).toBe('custom-class-name');

        // Проверяем, что прокинули restAttributes в нужный элемент
        expect(node.prop('restAttributes')).toBe('restAttributes');
      });

      it('should pass Ref into right HTML element', () => {
        const ref = createRef(); // preact createRef

        render({ componentRef: ref });
        expect(ref.current).not.toBeNull();
        expect(ref.current.className).toBe('dx-info');
      });

      it('should render children', () => {
        const node = render({ children: <div class="custom-class" /> });

        expect(node.find('.custom-class').exists()).toBe(true);
      });
    });

    describe('Bahavior', () => {
      describe('Effects', () => {
        // Также как и методы
      });

      describe('Methods', () => {
        it('should return right result from Getter/Method/Effect', () => {
        const component = new Component();

        expect(component._focused).toEqual(false);
        component.testMethod.apply(/* необходимый контекст */);
        expect(component._focused).toEqual(true);
      });
      });

      describe('Events', () => {
        // Также как и методы
      });
    });

    describe('Logic', () => {
      describe('Getters', () => {
        // Также как и методы
      });

      describe('Default Option Rules', () => {
        it('should apply `useInkRipple` to true', () => {
          // device: () => (themes as any).isMaterial(themes.current()),
          // options: { useInkRipple: true },
          materialThemeMock();

          expect(defaultOptionRules[0].device()).toBe(true);
          expect(defaultOptionRules[0].options).toBe({ useInkRipple: true });
        });
      });
    });
  });
  ```
</details>

  Имена тестов должны кратко отражать его суть. Все тесты должны начинаться со слов `should` или `should not`. Также стоит обратить внимание на именование групп тестов (`describe`). Имена должны быть осмысленными в совокупности с именем теста и "складываться" в предложение.
  
  Пара примеров из приведенного выше кода:
  
  - Widget Render - should pass Ref into right HTML element
  - Widget Render - should render children
  - Logic Default Option Rules - should apply `useInkRipple` to true

### Описание пропов

Очень важно, чтобы модель была описана целиком и полностью, не допускается каких-то неявных расширений, неописанных параметров. В *React* можно неописанные пропы передавать в компонент, а в *Angular* нельзя - отсюда такое ограничение.

Все пропы публичных компонентов должны быть необязательными. Для этого нужно задать для пропа инициализатор или сделать его опциональным, используя `?` токен, в этом случае одно из возможных значений пропа будет `undefined`.

```tsx
@ComponentBindings()
export class MyComponentProps {
  @OneWay() p1: string = "default value"; // Optional prop
  @OneWay() p2?: string; // Optional prop
  @OneWay() p2!: string; // Required prop
}
```

Для внутренних компонентов иногда удобно использовать обязательные пропы, чтобы не забыть передать их в компонент.
Для пропов, которые обязательно должны быть переданы в компонент, необходимо перечислить их ключи при декларации компонета.
В этом случает тайпскрипт будет сообщать о пропущенном пропе.

```tsx
@Component({ view: viewFunction })
export class MyComponent extends JSXComponent<MyComponentProps, "p1"|"p2">(MyComponentProps) {
}

<MyComponent /> // error p1, p2 is missed
```

Пропы не всегда удобно описывать с помощью класса. Например, компонент имеет подмножество пропов своего родительского компонента.
В этом случае можно объявить пропы так

```tsx
type Props = Pick<ParentProps, "p1"|"p2">;

@Component({ view: viewFunction })
export class MyComponent extends JSXComponent<Props>() {
}
```

### Жизненный цикл компонента

Хотя технически компонент записан в виде класса, лучше всего думать о нем, как о функции. Эта функция принимает на вход параметры и выдает разметку. Да, это функциональный react-компонент. Наш компонент в *React* представляет из себя именно функциональный компонент.

Поэтому *Model* это и есть входные данные, а *View* это вывод функции. Никаких других источников данных, знаний и прочего не должно быть.

Отсюда следует, что любое изменение пропертей, которое мы хотим внести приведет к перерисовке, и компонент целиком и полностью полагается на модель.

Любое изменение `@TwoWay` пропа заставит перерисоваться компонент, а новое значение будет в модели. Более подробно смотри в [use cases](#@TwoWay())

Любое изменение свойства самого компонента (не пропов) также вызывает перерисовку, но новое значение сохраняется в этом свойстве.

### Разметка и стили

Если при переписывании какого-то компонента на реновацию нет необходимости сильно менять его структуру (например, разбивать на подкомпоненты), то старайтесь сохранять имеющуюся *HTML* структуру, это позволит по максимуму использовать имеющиеся стили и избежать какого-либо рода БЧ.

Если же ваш старый компонент очень большой, то лучше разбивать его на более мелкие и атомарные. Но здесь кроется подводный камень - при выделении мелких компонентов, в итоговой разметке *Angular* компонентов появятся промежуточные кастомные теги (вы их все помните, *dx-button*, *dx-list-item* и прочие), тогда как в *React*, *Vue*, *jQuery* их не будет, будут обычные дивы.

Поэтому стоит особое внимание обращать на существующие стили, чтобы в них не было правил, полагающихся на структуру тегов разметки. Используйте классы.

Отсюда же естественный вывод - в реюзабельных компонентах имена классов не должны отсылать к чему-то большему, они должны относиться только к этому компоненту. Внешний компонент при необходимости сможет перекрыть/изменить стили внутреннего компонента.

### Использование необъявленных атрибутов

Одним из преимуществ нативных компонентов является добавление любых пользовательских атрибутов в *HTML* разметку. В *Angular* и *Vue* это решается на стороне самих фреймворков, для поддержки в *React* необходимо использовать геттер `restAttributes` - его не надо объявлять, он доступен сразу в первом аргументе *View* функции.

Этот геттер возвращает объект **дополнительных** атрибутов, которые пользователь повесил на нативный компонент.

Всегда предавайте `restAttributes` в рутовый эелемент (компонент это или нет) вьюхи. См. [пример](#Описание-компонента).

Есть два варианта использования

1. Пробросить в одноименный проп компонента *Widget*. Внутри *Widget* сделает все сам 🤗;
2. Добавить все проперти объекта в *HTML* разметку с помощью *spread* оператора.

   ```tsx
   <div
    {...restAttributes}
   >
   </div>
   ```

## Обратная совместимость

Мы не можем отказаться от многого, что есть в текущем *DevExtreme*, поэтому что-то в декларации будет выглядеть лишним, какие-то фичи фреймворков нельзя использовать.

Сколько это продлится - вопрос открытый, но пока мы с этим живем.

### Значения для TwoWay пропов

Всегда указывайте дефолтное значение для `TwoWay` пропов. Никогда не передавайте `undefined` как значение `TwoWay` пропа. При этом реализуйте компонент так, чтобы он мог принимать `undefined` - как остуствие значения. В этом случае компонент должен корректно отработать. Со стороны это выглядит как стирание значения (не фоллбек до дефолтного, а именно отсутсвие значения пропа). В большинстве случаев `null` должен вести себя так же. В основном это ограничение касается тех компонентов, которые регистрируют jQuery-виджет. Больше про `TwoWay` пропы читайте [тут](#twoway)

### Подписка на ивенты

Мы не можем использовать нативные ивенты фреймворков. Мы могли бы подписаться на `click` ивент прямо в *JSX* разметке и иметь нативные ивенты в каждом фреймворке. Но мы должны поддержать наши старые *dxEvents*. Поэтому все подписки на ивенты совершайте из `@Effect()`. См. примеры в [Use cases](#@Effect), а также рабочий код в [*button.tsx*](https://github.com/DevExpress/DevExtreme/blob/21_1/js/renovation/ui/button.tsx) и [*widget.tsx*](https://github.com/DevExpress/DevExtreme/blob/21_1/js/renovation/ui/common/widget.tsx)

### Ивенты комопнентов

При имплементации ивентов передавайте в аргументе только данные для этого ивента. Элемент и компонент передавать не надо - jQuery враппер позаботится об этом. Все ивенты оборачиваются в экшены, конфигурации экшенов указывайте в декораторе.

В некоторых существующих виджетах есть специальные ивенты на изменение значения виджета (`onValueChanged`, `onSelectionChanged` и тд). Скорее всего эти ивенты содержать больше информации, чем просто новое значение опции, например они содержат event объект, показывающий от какого дейтсвия юзера произошло изменение, либо дополнительные препроцешенные значения заселекченных айтемов и тд.

В большинстве случаев вам надо будет эти ивенты реализовать в компоненте. Обратите внимание, что на изменение `TwoWay` пропов у копонентов и так есть *change*-ивент, он в себе несет новое значение. Через этот ивент jQuery-враппер реализует вызов optonChanged. Поэтому, если тот другой ивент не содержит в себе какой-то уникальной информации, которую нельзя будет пользователю получить, рассмотрите вариант депрекейта этого ивента.

В случаях, когда в ивенте должны быть такие вещи, которые юзер никак не получит, но при этом они важны (event объект, например, о нажатой клавише и тп), то эти ивенты реализуйте так. В компоненте заведите ивент, который будет подготавливать эту дополнительныю информацию, вызывайте его перед сменой `TwoWay` пропа. Затем, в обраточике `_optionChanged` базового jQuery-виджета вашего компонента вызовите старый ивент со всеми нужными полями. Что такое базовый компонент, смотрите [тут](#ViewModel).

Пример реализации `onValueChanged` смотрите в `CheckBox` компоненте.

### Темплейты

Если темплейт используется для задания со стороны пользователя, то необходимо соблюдать следующие правила для поддержки обратной совместимости.

Параметры в темплейт стоит передавать в таком виде:
  - **data** - объект (или что-то еще) с параметрами для темплейта. В существующих виджетах этот параметр обычно зовется `itemData`, `buttonData` и тд (см. доку на темплейты)
  - **index** - если темплейт нужен для отрисовки коллекционных данных, то передавайте индекс. Это так же соотносится с существующими темплейтами (`itemIndex`).

```jsx
<div ...>
  …
  <div>
    {viewModel.template &&
      <viewModel.template
        data={{ someProp: viewModel.someProp }}
        index={0}
      />
    }
    {!viewModel.template &&
      <div>Default content</div>
    }
  </div>
</div>
```

Также из примера выше видно, что дефолтных темплейтов теперь нет. Проп темплейт теперь содержит только переданный извне темплейт. Никакого хранилища дефолтных темплейтов нет. Любой дефолтный вид компонента теперь не в темплейте, а прямо во *View*-функции. Но можно, конечно, завести небольшой компонент и рисовать его, если нет темплейта.

Для темплейтов, которые будут использоваться только нашими компонентами внутри, вышеуказанные правила можно не применять. Данные можно передавать как угодно (не обязательно `data` и `index`).

### registerKeyHandler

Для поддержки корректной работы этого метода в *jQuery* виджетах, в декларативных виджетах надо добавить *onKeyDown* ивент и правильно его обработать.

Корневой компонент (*Widget.tsx*) уже имеет такой ивент, райзит его на нажатии любой клавиши клавиатуры. В вашем компоненте надо на него подписаться, и делать свои действия (если вашему компоненту надо что-то делать при нажатии на клавиши). Однако сначала вам надо вызвать свой проп-ивент `onKeyDown`, и если он вернет `cancel == true`, то не выполнять свое действие.

См `onWidgetKeyDown` в [*Button.tsx*](https://github.com/DevExpress/DevExtreme/blob/67e81e01fe880851210cd20f638e0532235da521/js/renovation/ui/button.tsx#L193)

```typescript
onWidgetKeyDown(event: Event, options) {
  const { onKeyDown } = this.props;
  const { keyName, which } = options;

  const result = onKeyDown?.(event, options);
  if (result?.cancel) {
    return result;
  }

  if (...) {
    event.preventDefault();
    this.onWidgetClick(event);
  }
}
```

## Разработка

Переписывание старых сложных компонентов следует производить поэтапно, обновляя сначала маленькие составные части и внедряя их в старые виджеты.

### Именование и структура файлов, папок
Все компоненты пока размещаются в папке [js/renovation](https://github.com/DevExpress/DevExtreme/tree/21_1/js/renovation).

Краткие правила:
- Пробелы в файлах_заполняем_нижним_подчеркивание как в остальном devextreme.
- Javascript не допускается поэтому все включая утилитные функции пишем на ts.
- Мы не дублируем название папки в имени файла.
- Мы стараемся придерживаться правила [7+/-2](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%BE_%D1%81%D0%B5%D0%BC%D1%8C_%D0%BF%D0%BB%D1%8E%D1%81-%D0%BC%D0%B8%D0%BD%D1%83%D1%81_%D0%B4%D0%B2%D0%B0#:~:text=%C2%AB%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5%20%D1%87%D0%B8%D1%81%D0%BB%D0%BE%20%D1%81%D0%B5%D0%BC%D1%8C%20%D0%BF%D0%BB%D1%8E%D1%81%2D%D0%BC%D0%B8%D0%BD%D1%83%D1%81,%D0%B1%D0%BE%D0%BB%D0%B5%D0%B5%207%20%C2%B1%202%20%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2.) вовремя выделяя подпапки

Структура с описанием:
+ renovation
  + utils <- сюда кладем хелперные функции (*.ts)
  + common <- сюда кладем общие (использующие более чем в одном компоненте) файлы
   + events.d.ts <- общие типы
   + light_button_view.tsx <- общие компоненты, пропсы, viewFunction
  + pager <- папка компонента внутренности повторяют общую структуру
    + utils
    + common <- сюда кладем общие (использующие более чем в одном компоненте pager-а) файлы
    + pages
      + page.tsx
      + page_index_selector.tsx
      + small.tsx <- (а не pages_small.tsx)
    + pager.tsx
    + content.tsx <- (а не pager_content.tsx)
  + button.tsx <- простой однофайловый компонент

### Исходный код

Все декораторы, а также базовый `JSXComponent` необходимо импортировать из `devextreme-generator/component_declaration/common`.

Стартовый шаблон кода компонента:

```tsx
import {
  Component,
  ComponentBindings,
  JSXComponent,
  OneWay,
} from 'devextreme-generator/component_declaration/common';

export const viewFunction = (viewModel: Component) => {
  return (<div></div>);
};

@ComponentBindings()
export class ComponentProps {
  // Your props go here
}

@Component({ view: viewFunction })
export default class Component extends JSXComponent(ComponentProps) {
  // ViewModel getters, Effects, Refs, go here
}
```

Также смотрите [пример](#Описание-компонента) выше в этом гайде и уже реализованные компоненты в `js/renovation`.

### jQuery

Как уже говорилось [выше](#ViewModel), в общем случае jQuery враппер над вашим компонентом должен быть полность работоспособным без дополнительных усилий. Однако могут быть случаи, когда базовая обертка либо не очень подходит для конкретного случая, либо еще не содержит какую-то функциональность. В этом случае нужно реализовать промежуточную обертку (см [как реализована кнопка](https://github.com/DevExpress/DevExtreme/blob/21_1/js/renovation/preact_wrapper/button.ts)), в которой будет специфичный для компонента код.

Общую для всех jQuery компонентов функциональность стоит реализовывать в единой базовой обертке, однако это может потребовать правки со стороны генератора - в этом случае можно реализовать в промежуточной обертке, либо сообщить команде генераторов.

Внося правки в единый базовый враппер, убедитесь что все jQuery-врапперы генерятся и функционируют правильно.

### Тестирование компонентов

Тесты на декларации написаны с использование *jest*. Примеры тестов на существующие компоненты см в [testing/jest](https://github.com/DevExpress/DevExtreme/tree/20_2/testing/jest).

Стартовый шаблон кода test-a:
```tsx
/* eslint-disable jest/expect-expect */
import { h } from 'preact';
import { shallow } from 'enzyme';
import { _Component_, viewFunction as _Component_Component } from '<path>';

describe('_Component_', () => {
  describe('View', () => {
    it('render props', () => {
      const props = { props: {} } as Partial<_Component_>;
      const tree = shallow(<_Component_Component {...props as any} /> as any);
    });
  });
  describe('Behaviuor', () => {
    it('Getters', () => {
      const component = new _Component_({ /* параметры */ });
    });
  });
});

```

Для запуска тестов достаточно просто выполнить команду `test-jest`.

Для watch `test-jest --watch`.

Рекомендуется к использованию плагин [vscode-jest](https://marketplace.visualstudio.com/items?itemName=Orta.vscode-jest)

Также ознакомьтесь с информацией в [разделе тестирования](#тестирование).

### Playground

В папке *playground* есть приложения на *Angular*, *React* и *Vue*, демонстрирующие новую кнопку.

Для того, чтобы можно было посмотреть вживую на работу компонента в плейграунде его нужно скомпилировать под нужный фреймворк. Воспользуйтесь билдежными тасками

*React* - `build:react` либо `build:react:watch`

*Angular* - `build:angular` либо `build:angular:watch`

*Vue* - `build:vue` либо `build:vue:watch`

*jQuery* - если в декораторе вашего компонента указано `jQuery: { register: true }`, то при запуске тасок `build:r`, `dev:r`, `test-env` в дополнение к *Preact*-компоненту сгенерируется и *jQuery* враппер над ним. Имя для *jQuery*-виджета в точности совпадает с именем компонента.

Для добавления jQuery виджета в основной бандл (и для использования его в тестах) следует добавить соответствующую запись в этот файл (js/bundles/modules/parts/renovation.js).

### Оформление багов

В ходе разработки могут быть выявлены ошибки генератора. Для оформления бага следует завести соответствующее issue, следуя темплейту в репозитории [devextreme-renovation](https://github.com/DevExpress/devextreme-renovation).

### Ограничения

1. Нельзя использовать пропы с именем `style`.

1. Компоненты, для которых регистрируется jQuery виджет, должны использовать `div` как корневой элемент.

1. Во view функции можно использовать только пропсы, а так же константы и стрелочные функции. Это связано с некоторыми техническими ограничениями.

    Следующий код не заработает:
    ```tsx
    function myFunc() {
      return "";
    }

    const viewFunction = () => <div className={myFunc()}></div>
    ```

    Однако этот код, будет работать:
    ```tsx
    const myFunc = () => {
      return "";
    };

    const viewFunction = () => <div className={myFunc()}></div>
    ```

    Импортируемые функции также должны быть стрелочными:
    ```tsx
    export { myFunc } from './utils'; // myFunc - стрелочная функция!

    const viewFunction = () => <div className={myFunc()}></div>
    ```

1. При использовании внешних констант и стрелочных функций нельзя допускать пересечения их имен с геттерами и методами компонента (это ограничение связано с предыдущим пунктом). Это ограничение распространяется и на эксопртируемые стрелочные функции и константы.

    Следующий код не заработает:
    ```tsx
    const calculateValue = () => { };

    const someClass = "";

    @Component()
    class Widget {
      calculateValue() {
      }

      get someClass() {
        return "";
      }
    }
    ```

1. Из-за сохранения обратной совместимости в `@Component` невозможна реализация полей с именами `state` и `render`. Однако могут существовать методы `state()` и `render()`, а так же попрса `state` (поле в `@ComponentBinding`).

### Use Cases

В этом разделе опишем подробнее как и для чего использовать те или иные декораторы, конструкции и прочее. А также более интересные примеры и случаи.

#### @OneWay()

Этим декоратором помечаются обычные пропы компонента. Если ваш компонент ожидает чего-то на входе, что он будет **только читать**, то это оно.

Например, `type`, `title` и т.д. элемента `<input>`

```tsx
@ComponentBindings()
class MyComponentProps {
  @OneWay() type: 'bad' | 'good' = 'good';
}

@Component({ view: viewFunction })
class MyComponent extends JSXComponent(MyComponentProps) {
}

function viewFunction(viewModel) {
  return <span>I'm a {viewModel.props.type} guy</span>
}
```

`OneWay` пропы можно только читать, они предоставляют компоненту некую информацию, необходимую ему для правильного отображения, определения поведения и прочее.

#### @TwoWay()

`TwoWay` пропы делают все то же самое, что и `OneWay`, предоставляют компоненту входные параметры.

Однако, `TwoWay` значение может быть изменено как пользователем, так и самим компонентом изнутри. Поэтому он и называется двухсторонним.

При присваивании нового значения произойдет перерендер компонента, при этом новое значение можно будет считать из этого пропа.

Также пользователь вашего компонента получит оповещение, что значение этого пропа сменилось. В *React* можно будет подписаться на специально созданный ивент, в *Angular* можно будет настроить двусторонний байндинг и т.п.

Технически это значит следующее:

Для любого `TwoWay` пропа заводится соответствующий `Event` с именем `propName`+`Change`. Например, для `TwoWay` пропа `pressed` в модели также появится `Event` `pressedChange`.

Этот *сhange*-ивент не надо объявлять до тех пор, пока вам не понадобится подписаться на изменение `TwoWay` пропа в другом компоненте.

Если вы создаете компонент (A), который хочет подписаться на *сhange*-ивент другого компонента (B), то у компонента (B) должен быть объявлен необходимый `Event`. Это нужно только для корректной передачи пропов в декларации, на сгенерированный код это никак не влияет.

Но вам не надо вызывать этот *сhange*-ивент, он просто должен быть объявлен, если вам он нужен для подписки.

**Еще раз. Наличие или отсутствие этого пропа в декларации не влияет на конечный результат генерации.**

Немного другая ситуация с `deaultProp`. Сгенерированный компонент для React также будет для каждого `TwoWay` пропа иметь соответствующий `default` проп, например, `defaultPressed`. Нужен этот дефолтный проп тогда, когда кто-то хочет только установить значение по-умолчанию для какого-то свойства, но не хочет управлять его значением. Подробнее об управляемых и неуправляемых компонентах читайте, например, [здесь](https://reactjs.org/docs/forms.html#controlled-components) и [здесь](https://reactjs.org/docs/uncontrolled-components.html). В Ангуляр и VueJS компоненте такого *default*-свойства не будет.

Не заводите *default* пропов для `TwoWay` пропов в декларации. Это может привести к некорректной генерации компонентов в разных фреймворках. Также всегда используйте компоненты в *controlled* режиме.

Q. Почему это так сложно сделано? Почему мне нельзя самому завести стейт, его менять, вызывать *change*-ивент и смотреть на дефолтное значение?

A. Потому что в разных фреймворках мы генерируем немного разные конструкции (хоть в их сути и лежит одно и то же). А также эти конструкции позволяют использовать наши компоненты в *controlled* и *uncontrolled* режимах.

Рассмотрим эти режимы подробнее

У нас есть компонент, который имеет `TwoWay` проп и меняет его по клику. Некий счетчик.

```tsx
@ComponentBindings()
class MyComponentProps {
  @TwoWay() value: number = 0;
}

@Component({ view: viewFunction })
class MyComponent extends JSXComponent(MyComponentProps) {
  onClick() {
    this.props.value = this.props.value + 1;
  }
}

function viewFunction(viewModel) {
  return <span>Counter - {viewModel.props.value}</span>
}
```

Мы тут не задавали ни ивента, ни дефолтного пропа. Но они есть :)

**Сценарий 1**

Пользователь просто создал компонент и ему больше ничего не интересно. От каких-то манипуляций с *UI* конечного пользователя меняется значение `TwoWay` пропа, и компонент будет перерисовывается.

```tsx
<MyComponent />
```

**Сценарий 2**

Пользователь компонента хочет знать об изменениях этого значения, но на этом все. Он получит оповещение, новое значение и что-то там у себя сделает.

```tsx
<MyComponent valueChange={onCounterChange} />

onCounterChange(counter) {
  log(counter)
}
```

Тут каждый раз при клике на нашем компоненте, вышестоящий компонент будет логировать числа 0,1,2,3...

Для нас эти два сценария ничем не отличаются - мы на новом цикле рендера получим то значение, которое записали в `TwoWay` проп.

Это значит, что наш компонент никто не контролирует, компонент сам установил новое значение и его же и получает.

**Сценарий 3**

Пользователь компонента указывает значение, подписывается на изменение, а также принимает решение, что же делать с этим измененным значением перед отправкой обратно в компонент, ну например он хочет сбрасывать счетчик после 5.

Он контролирует наш компонент, он решает какое мы значение получим. Хоть мы и записали в проп новое значение, на рендере нам может придти другое значение и мы его и будем рисовать

```tsx
<MyComponent value={counterValue} valueChange={onCounterChange} />

onCounterChange(counter) {
  this.counterValue = 1 // здесь в реакте скорее всего будет некий setState, а в Ангуляре нет, нам это сейчас не важно

  if(counter > 5)
    this.counterValue = 1

  log(this.counterValue)
}
```

В этом случае будут залогированы последовательности с 1 по 5.

**Сценарий 4**

А что если вы хотите задать только начальное значение счетчика, но не хотите его контролировать. В React и Vue компоненте такая возможность будет, в Ангуляре тоже. Но реализовано это будет по-разному. Поэтому в декларативном компоненте такая возможность остутствует - если вы передали значение в компонент, то дальше вы должны его контролировать.

**Выводы**

Нам в компоненте не нужно ничего делать, чтобы поддержать эти два режима, мы просто объявляем `TwoWay` проп и присваиваем ему значение, когда надо. А потом просто на рендере считываем из пропа значение и его рисуем. Мы не зовем *change*-ивент, мы не создаем никакого *default* пропа. Это все не нужно для написания декларативного компонента, мы пишем только логику - а логика у нас это смена значения.

Однако если представить, что примеры выше это все тоже наши декларативные компоненты, то чтобы *typescript* не ругался и мы в декларативных компонентах видели, что там есть *change*-ивенты для `TwoWay` пропов, их нужно задекларировать.

Поэтому наш компонент будет выглядеть так:

```tsx
@ComponentBindings()
class MyComponentProps {
  @TwoWay() value: number = 0;
  @Event() valueChange?: (value: number) => void;
}

@Component({ view: viewFunction })
class MyComponent extends JSXComponent(MyComponentProps) {
  onClick() {
    this.props.value = this.props.value + 1;
  }
}

function viewFunction(viewModel) {
  return <span>Counter - {viewModel.props.value}</span>
}
```

Я объявил, но не использую в декларативном компоненте *change*-ивент.

**Важно** Исходя из вышесказанного, надо быть аккуратнее в тестах. Обращать внимание в каком режиме вы используете ваш комопнент в тестах.

Если вы хотите протестировать логику смены значения `TwoWay` пропа и проверяете его через отрисовку - не назначайте сам проп компоненту.

Еще раз вспомним [жизненный цикл нашего компонента](#Жизненный-цикл-компонента).

**Важный аспект об undefined и null**

При разработке компонента обратите внимание на то, что нельзя передавать в `TwoWay` проп значение `undefined`. Продиктовано это таргет-фреймворками. При этом компонент должен корректно отрабатывать вариант передачи `undefined`. То есть вам его передавать нельзя, но компонент должен работать.

Передавать можно `null`. В большинстве случаев он должен себя вести так же как и `undefined`. Однако есть случаи так называемых специальных значений (третий режим чекбокса, недетерминированный вид прогрессбара) - тут стоит использовать `null` как это специальное значение.

Как следствие из этого, всегда указывайте дефолтное значение для `TwoWay` пропов.

#### @Nested()

Как было уже сказано, это OneWay проп, и обращение к нему происходит как к OneWay, то есть мы можем только читать оттуда данные. При этом он собирает эти данные как со свойств, так и с nested компонентов.

**Важно!** Во избежание ошибок, рекомендуется именовать `ComponentBingings` как `{SomeName}Props` (см. пример ниже). Это связано с возможным пересечением генерируемых имен нестед компонентов и типов.

Пример использования:

```ts
@ComponentBindings()
export class Column {
  @OneWay() dataField: string = "Default Value";
  // Other props
}
@ComponentBindings()
export class EditingProps {
  // Props
}

@ComponentBindings()
export class GridProps {
  @Nested() columns?: (Column | string)[];
  @Nested() gridEditing?: EditingProps;
}

@Component({ view: viewFunction })
class MyComponent extends JSXComponent(GridProps) {
  getColumnNames() {
    return this.props.columns.map(col => typeof col === "string" ? col : col.dataField);
  }
}

```

#### @Event()

Как вы уже догадались, этот проп это колбек. Зачем его отделять от `OneWay` пропа, можно же в простой проп функцию передать?

Да, можно, но для других каких-то целей (например для темплейтов). А если вы хотите правильные ивенты во всех фреймворках, помечайте такие пропы `Event` декоратором - это обеспечит корректную работу (файринг) ивентов везде.

Так вот, ивент - это колбек, принимающий 1 параметр и возращающий или ничего или результат с *cancel* и прочее. Главное тут это 1 параметр.

Из нашего же примера выше видно как задать ивент. Однако мы его там не звали. Так давайте это исправим. В примере мы позовем колбек на клике, проверим результат и отменим дефолтное действие.

```tsx
@ComponentBindings()
class MyComponentProps {
  @OneWay() type: 'bad' | 'good' = 'good';
  @Event() onClick?: (e: { type: 'bad' | 'good' }) => any;
}

@Component({ view: viewFunction })
class MyComponent extends JSXComponent(MyComponentProps) {
  onClickHandler() {
    const { cancel } = this.props.onClick?({ type: this.props.type })
    if(cancel) {
      return;
    }

    // Do something
  }
}

function viewFunction(viewModel) {
  return <span>I'm a {viewModel.props.type} guy</span>
}
```

#### @Ref()

Рефы предоставляют ссылку на элемент или другой компонент для доступа к *DOM* или *API* другого компонента.

Для корректной инициализации рефов их надо объявить и передать как спец-проп `ref` в нужный элемент (компонент):

```tsx
@ComponentBindings()
class MyComponentProps {}

@Component({ view: viewFunction })
class MyComponent extends JSXComponent(MyComponentProps) {
  @Ref() rootRef!: HTMLDivElement;
}

function viewFunction(viewModel: MyComponent) {
  return (
    <div ref={viewModel.rootRef}></div>
  );
}
```

Реф может быть также передан в качестве пропа в дочерний компонент.

```tsx
@ComponentBindings()
class MyComponentProps {
  @Ref() parentElement?: HTMLDivElement;
}

@Component({ view: viewFunction })
class MyComponent extends JSXComponent(MyComponentProps) {
  @InternalState() width: number = 0;

  @Effect()
  calculateWidth(){
    this.width = getWidth(this.parentElement) / 2;
  }
}

```

Примеры использования рефов смотри ниже.

#### @ForwardRef()

*ForwardRef*, как и *Ref*, предоставляет ссылку на элемент или другой компонент для доступа к *DOM* или *API* другого компонента.
Отличие заключается в том, что *ForwardRef* инициализируется в дочернем компоненте.

```tsx
//parent.tsx

import ChildComponent from "./child";

@ComponentBindings()
class ParentProps {}

@Component({ view: parentView })
class ParentComponent extends JSXComponent(ParentProps) {
  @ForwardRef() childElement!: HTMLDivElement;

  @Effect()
  effect(){
    // You have access to childElement here
    const childWidth = getWidth(this.childElement);
  }
}

function viewFunction(viewModel: ParentComponent) {
  return (
    <ChildComponent elementRef={viewModel.childElement}/>
  );
}
```

```tsx
//child.tsx

@ComponentBindings()
class ChildProps {
  @ForwardRef() elementRef!: HTMLDivElement;
}

@Component({ view: parentView })
class ChildComponent extends JSXComponent(ParentProps) {

}

function viewFunction(viewModel: ChildComponent) {
  return (
    <div ref={viewModel.props.elementRef}></div>
  );
}
```

#### @Effect()

Этим декоратором помечаются методы компонента, которые вызываются после того, как компонент отобразится в дереве. Внутри этих методов можно обращаться к реальному DOM с помощью [рефов](#@Ref()).

Зачем использовать Эффекты - для взятия реальных размеров, для оформления всевозможных подписок и так далее. В общем всего того, что нельзя сделать декларативно. Обычно здесь находится код, который каким-либо образом взаимодействует с разметкой.

Компонент может содержать сколько угодно эффектов. Вообще один эффект (метод) должен быть посвящен чему-то одному. Старайтесь логически разбивать клиентскую функциональность на эффекты. Разные по природе эффекты должны оформляться в разных методах.

Если вы делаете некие подписки в эффекте, то вам необходимо вернуть колбек отписки.

Стоит помнить, что все эффекты вызываются асинхронно, также в разных фреймворках их реализация отличается. Поэтому и воспринимать их надо как атомарные действия, которые не зависят друг от друга и выполняются асинхронно (не сразу в момент рендера), а после. Не стоит закладываться на порядок их выполнения.

Для большей информации смотрите хук [useEffect](https://reactjs.org/docs/hooks-effect.html) в *React*.

```tsx
import { subscriber } from './utils/subscriber';

@ComponentBindings()
class MyComponentProps {
    @OneWay() p: string = "10";
    @TwoWay() s: number = 10;
}

@Component({
    view: viewFunction
})
class MyComponent extends JSXComponent(MyComponentProps) {
    @Effect()
    singleEffect() {
      const id = subscriber.on(() => {
        // do something
      });
      return () => subscriber.off(id)
    }
}

function viewFunction(viewModel: MyComponent) {
  return (<div></div>);
}
```

#### @Template()

В этом пропе в компонент придет нечто, что можно отрисовать, передав ему какие-то параметры-пропы. Можно представить, что это другой компонент или *render*-функция.

Все что нам нужно - корректно указать *props* во *View*-функции. Ну собственно так, будто мы просто рендерим другой компонент.

Ну и наши декларативные компоненты конечно могут выступать в роли темплейтов в других компонентах. Если вам необходимо указать пропсы, используемые каким-либо компонентом в качестве пропсов темплейта, используйте тип JSXTemplate.

Также не забывайте о правилах [обратной совместимости](#Темплейты) для *jQuery* виджетов.

```tsx
import {
  ...,
  JSXTemplate
} from 'devextreme-generator/component_declaration/common';
import { SomeWidgetProps } from './some_widget';

@ComponentBindings()
class MyComponentProps {
  @OneWay() item?: Item;
  @Template() itemTemplate?: any;
  @Template() componentTemplate?: JSXTemplate<SomeWidgetProps>;
}

@Component({ view: viewFunction })
class MyComponent extends JSXComponent(MyComponentProps) {
}

function viewFunction(viewModel) {
  const useTemplate = !!viewModel.props.itemTemplate;
  return (
    <div>
      {
        useTemplate &&
        <viewModel.props.itemTemplate
          data={{ item: viewModel.props.item }} />
      }

      {
        !useTemplate &&
        <span>{viewModel.props.item.text}</span>
      }
    </div>
  );
}
```

#### @Slot()

Этим декоратором необходимо помечать пропы, которые предполагается использовать для рендера готового контента от пользователя. Технология имеет много имен, но принцип один и тот же - необходимо в компоненте отобразить уже готовую разметку.

В *Angular* это *Content Projection*, в *Vue* это слоты и т.п.

Слоты могут быть именованными и неименованными. Однако, в наших компонентах все слоты именованные. С одним небольшим нюансом - если вы определите слот с именем `children`, то он будет использоваться в соответствующих технологиях на местах неименованного слота - в этот слот попадает весь контент, который не попадает в другие именованные слоты.

Рассмотрим пример задания слотов в компоненте и использование их снаружи

```tsx
@ComponentBindings()
class ComponentWithSlotsProps {
  @Slot() children?: any;
  @Slot() namedSlot?: any;
}

@Component({ view: viewFunction })
class ComponentWithSlots extends JSXComponent(ComponentWithSlotsProps) {
}

function viewFunction(viewModel: ComponentWithSlots) {
  return (
    <div>
      <div>
        { viewModel.props.namedSlot }
      </div>
      <div>
        { viewModel.props.children }
      </div>
    </div>
  );
}
```

```tsx
import ComponentWithSlots from './component-with-slots';

@ComponentBindings()
class MyComponentProps {
}

@Component({ view: viewFunction })
class MyComponent extends JSXComponent(MyComponentProps) {
}

function viewFunction(viewModel: MyComponent) {
  return (
    <ComponentWithSlots
      namedSlot={
        <div>
          Content for named slot
        </div>
      }
    >
      <div>
        Default content
      </div>
    </div>
  );
}
```

В *DevExtreme* есть поддержка анонимных темплейтов, в новом *DevExtreme* стоит использовать слоты.

**Важно!** 
*Slot* может принимать параметр с полем isSVG *@Slot({isSVG: boolean})*. Ему необходимо задать значение *true*, если виджет не является SVG-виджетом, но принимает SVG контент. *TODO: link on Base viz widget*

#### @Method()

Этим декоратором помечаются методы компонента, которые должны представлять внешнее *API*.

Особое внимание стоит уделить тому, что *API* должно содержать только минимум необходимых методов - все, что может быть сделано через пропы, должно быть сделано через них.

Классическим примером такого *API* является *focus* и *export/print*.

Переключить видимость, открыть/закрыть дровер и прочие **НЕ** являются примером *API* - эти примеры могут и должны быть решены через пропы.

Итак, в теле методов, помеченных как `Method` есть доступ к *DOM*. Однако как указывалось ранее, лучше код работы с *DOM* и т.п. выделить в отдельную утилиту, протестировать отдельно, а в компоненте уже решать вопросы на более высоком уровне.

**Важно!** Все методы, помеченные декоратором `@Method()`, можно вызывать только после рендера компонента. Их может вызвать только другой компонент, либо код, тригерящийся от действий конечного пользователя (на обработчиках событий, например). Это значит, что не должно быть вызовов этих методов во *View*-функции или геттерах компонента.

```tsx
@ComponentBindings()
class MyComponentProps {
  @OneWay() type: 'bad' | 'good' = 'good';
}

@Component({ view: viewFunction })
class MyComponent extends JSXComponent(MyComponentProps) {
  @Ref() rootRef!: HTMLDivElement;

  @Method()
  export(format: string) {
    if(false) {
      // Реф используется как элемент, на который он указывает
      return this.rootRef.innerHTML;
    }
    // Но лучше как-то так
    return exportUtils.exportElement(this.rootRef, format);
  }
}

function viewFunction(viewModel: MyComponent) {
  return (
    <div ref={viewModel.rootRef}>
      <span>I'm a {viewModel.props.type} guy</span>
    </div>
  );
}
```

Доступ к *API* одного декларативного компонента внутри другого осуществляется через *ref*.

```tsx
import MyEditorComponent from './my_funny_editor';

@ComponentBindings()
class MyComponentProps {
  @OneWay() type: 'bad' | 'good' = 'good';
}

@Component({ view: viewFunction })
class MyComponent extends JSXComponent(MyComponentProps) {
  @Ref() editorRef?: MyEditorComponent;

  @Method()
  focus() {
    // У компонента MyEditorComponent есть API метод, помеченный декоратором @Method()
    return editorRef?.focus();
  }
}

function viewFunction(viewModel: MyComponent) {
  return (
    <div>
      <MyEditorComponent ref={viewModel.editorRef} editorProp={viewModel.props.type} />
    </div>
  );
}
```

#### Context

Контекст служит для неявной передачи данных от родителя к потомкам. Контекст стоит использовать для передачи глобальных настроек или данных, например `rtlEnabled` конфиг или глобальное хранилище данных в плагинной системе.

##### Создание контекста

```tsx
import { createContext } from 'devextreme-generator/component_declaration/common';

const defaultValue = false;
const RtlEnabledContext = createContext<boolean>(defaultValue);

```

##### Передача контеста 

Для передачи контекста необходимо использовать проперти компонента или геттер. Для этого его необходимо отметить декоратором `Provider`.

```tsx
import { Provider, JSXComponent, ComponentBindings, OneWay } from 'devextreme-generator/component_declaration/common';

@ComponentBindings()
export class Props {
  @OneWay() rtlEnabled = false;
}

@Component()
export class ProviderComponent extends JSXComponent(Props){
  @Provider(RtlEnabledContext)
  get rtlEnabledProvider(){
    return this.props.rtlEnabled;
  }
} 
```

##### Получение контекста

Получить контекст может проперти компонента, отмеченное декоратором `Counsumer`. Такое проперти будет иметь значение ближайшего провайдера контекста, найденного вверху дерева. Если такого провайдера нет, то значение будет равно `defaultValue` (см [Создание контекста](#cоздание-контекста)).

```tsx
import { Consumer, JSXComponent, ComponentBindings, OneWay, Component } from 'devextreme-generator/component_declaration/common';


const view = ({ rtlEnabled }: ConsumerComponent) => 
  (<div dir={rtlEnabled?"rtl":"ltr"}></div>)

@ComponentBindings()
export class Props {
}

@Component()
export class ConsumerComponent extends JSXComponent(Props){
  @Consumer(RtlEnabledContext)
  rtlEnabled!: boolean;
} 

```

#### JSX

Как уже писалось ранее, мы используем *JSX* для описания разметки компонента. Любой код на *JSX* должен быть только внутри *View*-функции.

Также *View*-функция должна вернуть *JSX* разметку с одним корневым элементом. Если ваш компонент должен вернуть более одного, их следует обернуть в специальный элемент `Fragment`, который не будет отображен в дереве.

**Ограничение** Если компонент регистрирует jQuery виджет, то его корневым элементом может быть только `div`.

```tsx
import { Fragment } from 'devextreme-generator/component_declaration/common';

@ComponentBindings()
class MyComponentProps {
}

@Component({ view: viewFunction })
class MyComponent extends JSXComponent(MyComponentProps) {
}

function viewFunction(viewModel: MyComponent) {
  return (
    <Fragment>
      <div>
        First element
      </div>
      <div>
        Second element
      </div>
    </Fragment>
  );
}
```

#### Portals

Portal - специальный JSX компонент, позволяющий рендерить элемент в любом месте в DOM-е. Этот компонент принимает на вход всего один параметр - container. Это может быть ссылка, на элемент, либо конкретный HTML элемент (например, полученный через `document.getElementByID()`). При этом компонент продолжает получать свойства, переданные родителем и рендерить разметку, на основе этих свойств. Самые частые сценарии использования порталов - `drag-drop` элементы и элементы, которые должны рендерится поверх остальных (например, `Overlay`). Обратите внимание, что при первом рендере разметки во фреймворках отсутствуют ссылки, они появляются только после первого рендера. Это надо учитвывать при разработке таких опций как `opened` в `Lookup` (пример WA - см. пример)

**Важно!** При использовании элементов, полученных через `document` (например `document.body`, см. пример), необходимо выносить их в геттеры. Это позволит компонентам правильно пересчитывать ссылки во всех подходах. При разработке компонентов учитывайте возможность их рендера в SSR, где `document` на этапе создания не существует и искомый компонент может быть `undefined`.

В некоторых подходах (React, Preact), портал ожидает увидеть один элемент, в качестве потомка. Если вам необходимо сгенерить несколько компонентов рядом в одном портале - оберните их во `Fragment`.

Пример:

```tsx
import { Portal } from 'devextreme-generator/component_declaration/common';

@ComponentBindings()
class MyComponentProps {
  @Ref() someElement!: HTMLDivElement;
  @OneWay() opened: boolean = false;
}

@Component({ view: viewFunction })
class MyComponent extends JSXComponent(MyComponentProps) {
  rendered = false;
  get bodyElement() {
    return document?.body;
  }
  
  @Effect({ run: 'once' })
  afterInit() {
    this.rendered = true;
  }
}

function viewFunction(viewModel: MyComponent) {
  return (
    <div>
      <Portal container={viewModel.bodyElement}>
        <div>
          Element in body
        </div>
      </Portal>
      {viewModel.rendered && viewModel.props.opened && <Portal container={viewModel.props.someElement}>
        <div>
          Element by ref
        </div>
      </Portal>}
    </div>
  );
}
```

#### Динамические компоненты

Крупные компоненты могут иметь нестатическую разметку, например, при реализации плагинов. В этом случае необходимо использовать динамические компоненты, которые будет рисовать некий ```placeholder``` компонент в зависимости от подключенных плагинов.

Ниже представлена декларация такого компонента

```typescript

import {
    JSXComponent, Component, ComponentBindings, OneWay, Fragment, JSXTemplate, InternalState,
} from "../../../component_declaration/common";

import { PlaceholderItemProps } from "./placeholder-props"; // здесь объявленны обычные пропсы компоненты см. [ComponentBindings](#описание-компонента)

export function viewFunction({
    currentComponent: CurrentComponent,
    props: { column, index },
}: Placeholder) {
    return <Fragment>
        {
            CurrentComponent
            && (
                <CurrentComponent
                    value={v}
                    onClick={onClick}
                    template={() => <Placeholder column={column} index={index + 1} />}
                />
            )
        }
    </Fragment>
}
  
  
const plugins: JSXTemplate<PlaceholderItemProps>[] = [];

/*
Экспорт функции, которая используется для регистрации динамических компонентов
*/
export const register = (component: JSXTemplate<PlaceholderItemProps>) => {
    plugins.unshift(component);
};
  
@ComponentBindings()
export class PlaceholderProps {
    @OneWay() column = 0;
    @OneWay() index = 0;
}
  
@Component({ defaultOptionRules: null, view: viewFunction })
export class Placeholder extends JSXComponent<PlaceholderProps>() {
    get currentComponent(): JSXTemplate<PlaceholderItemProps> {
        return plugins[this.props.index];
    }
}

```

Ниже код компонента который будет рисовать наш плейсхолдер

```typescript
import {
    JSXComponent, Component,
    Fragment
} from "../../../component_declaration/common";

import { PlaceholderItemProps } from "./placeholder-props";
import Button from "../button";

function view({ props: { value, onClick, template: Template } }: ButtonItem) {
    return <Fragment>
        <Button onClick={onClick} >{value}</Button>
        <Template />
    </Fragment>
}

@Component({
    view,
})
export default class ButtonItem extends JSXComponent<PlaceholderItemProps, "template">() { 

}
```